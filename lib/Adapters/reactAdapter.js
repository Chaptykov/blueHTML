//@module blueHTML.Adapters
//@class ReactAdapter @extend Adapter
//This class is by NO mean try to be a production ready solution. There are MANY implication on using this code for any purpose rather than simple tests.
//Make sure you understand how this conversion works in order to used for anything.
var adapter = {
	//@property {String} Name
	name: 'R'
	//@property {String} emptyTagCollection Specify the returned string when a block tag element has none children
,	emptyTagCollection: '[]'
	//@method defineAttribute
	//@param {CodeGenerationContext} code_generation_context
	//@param {String} object_name Name of the object used to accumulate the result of the code generation process
	//@param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes.
	// Besides notice that it can also be a piece of code
	//@return {String}
,	defineAttribute: function (code_generation_context, object_name, property_name)
	{
		'use strict';

		//This is a simple hack to avoid having to create a new plugin just for this
		if (property_name === '"class"')
		{
			property_name = '"className"';
			code_generation_context.keyName = 'className';
		}

		return object_name + '['+property_name+']="";';
	}
	//@method accumulateFinalAttributesResult Wrap up the final result after all attributes were converted to code
	//@param {CodeGenerationContext} attributes_result
	//@param {String} code_generation_context
	//@return {String}
,	accumulateFinalAttributesResult: function (code_generation_context, attributes_result)
	{
		'use strict';

		if (attributes_result)
		{
			return '(function (){var '+code_generation_context.objectName+' = {}; ' + attributes_result + 'return '+code_generation_context.objectName+';})()';
		}
		return 'null';
	}
	//@method setPropertysValue
	//@param {CodeGenerationContext} code_generation_context
	//@param {String} property_definition String generated by the invocation of the method defineProperty
	//@param {String} property_accumulated_values Result of the code generation process applied to all the properties value
	//@return {String}
,	setAttributeValue: function (code_generation_context, property_definition,  property_accumulated_values)
	{
		'use strict';

		return property_definition + property_accumulated_values;
	}
	//@method accumulatePropertysValue
	//@param {CodeGenerationContext} code_generation_context
	//@param {String} object_name Name of the object used to accumulate the result of the code generation process
	//@param {String} property_value Value of the property to set
	//@return {String}
,	accumulateAttributeValue: function (code_generation_context, object_name, property_value)
	{
		'use strict';

		return object_name + '["'+code_generation_context.keyName+'"]+=' + property_value +';';
	}
	//@method defineBlockTag
	//@param {CodeGenerationContext} code_generation_context
	//@param {String} attributes_result Result of generating the code to all of the tag attributes
	//@param {String} children_result Accumulated result for all tag's children
	//@return {String}
,	defineBlockTag: function (code_generation_context, tag_type, attributes_result, children_result)
	{
		'use strict';

		return 'reactCreateElementWrapper("' + tag_type + '",'+ attributes_result + (children_result !== this.emptyTagCollection ? ',' + children_result : '')+')';
	}
	//@method defineSingleTag
	//@param {CodeGenerationContext} code_generation_context
	//@param {String} attributes_result Result of generating the code to all of the tag attributes
	//@return {String}
,	defineSingleTag: function (code_generation_context, tag_type, attributes_result)
	{
		'use strict';

		return 'reactCreateElementWrapper("' + tag_type + '",'+ attributes_result+')';
	}
	//@method defineTextTag
	//@param {CodeGenerationContext} code_generation_context
	//@param {String} text Take into account that this variable can contain code to be evaluated!
	//@return {String}
,	defineTextTag: function (code_generation_context, text)
	{
		'use strict';

		return text;
	}
	//@method accumulateFinalTagsResult Wrap up the final result get after all tags were converted to code. Please notice that at this point the string code
	//passed in generation_result parameter contains the entire resulting code
	//@param {CodeGenerationOptions} options
	//@param {CodeGenerationResult} geneation_result
	//@return {geneation_result}
,	accumulateFinalTagsResult: function (options, geneation_result)
	{
		'use strict';

		if (!options.notGenerateContext)
		{
			var deps = geneation_result.contextName + (geneation_result.externalDependencies.length > 0 ? ',' +geneation_result.externalDependenciesObjectName : '' );

			geneation_result.value = this._removeBrackets(geneation_result.value);

			geneation_result.value =
				'function ('+deps+') { return React.createClass({ render: function () { '+reactCreateElementWrapper.toString()+' return ' + geneation_result.value + '; }});}';
		}

		return geneation_result;
	}

	//@method _removeBrackets Auxiliary method to remove bracket generated by the fist call to the Tags iteration method (iterateOverTagNodes)
	//@param {String} code Code to clean
	//@return {String}
,	_removeBrackets: function (code)
	{
		'use strict';

		if (code.indexOf('[') === 0)
		{
			code = code.substr(1);
		}
		if (code.indexOf(']', code.length - 1) !== -1)
		{
			code = code.substr(0, code.length -1);
		}
		return code;
	}
};

function reactCreateElementWrapper (tag_type, attributes, children)
{
	var params = children || [];
	params.unshift(tag_type, attributes);

	return React.createElement.apply(React.createElement, params);
}

module.exports = adapter;