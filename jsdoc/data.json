window.__shortjsdoc_data = {"source":"\n\n//@filename {Foo} fileName ./lib/Adapters/incrementalDOMAdapter.js\n\n//@module blueHTML.Adapters\n//@class IncrementalDOMAdapter @extend Adapter\nvar adapter = {\n\t//@property {String} Name\n\tname: 'ID'\n\t//@method defineAttribute\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} object_name Name of the object used to accumulate the result of the code generation process\n\t//@param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes.\n\t// Besides notice that it can also be a piece of code\n\t//@return {String}\n,\tdefineAttribute: function (code_generation_context, object_name, property_name)\n\t{\n\t\t'use strict';\n\n\t\treturn object_name + '['+property_name+']=\"\";';\n\t}\n\t//@method setPropertysValue\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} property_definition String generated by the invocation of the method defineProperty\n\t//@param {String} property_accumulated_values Result of the code generation process applied to all the properties value\n\t//@return {String}\n,\tsetAttributeValue: function (code_generation_context, property_definition,  property_accumulated_values)\n\t{\n\t\t'use strict';\n\n\t\treturn property_definition + property_accumulated_values;\n\t}\n\t//@method accumulatePropertysValue\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} object_name Name of the object used to accumulate the result of the code generation process\n\t//@param {String} property_value Value of the property to set\n\t//@return {String}\n,\taccumulateAttributeValue: function (code_generation_context, object_name, property_value)\n\t{\n\t\t'use strict';\n\n\t\treturn object_name + '[\"'+code_generation_context.keyName+'\"]+=' + property_value +';';\n\t}\n};\n\nmodule.exports = adapter;\n\n//@filename {Foo} fileName ./lib/Adapters/reactAdapter.js\n\n//@module blueHTML.Adapters\n//@class ReactAdapter @extend Adapter\nvar adapter = {\n\t//@property {String} Name\n\tname: 'R'\n\t//@property {String} emptyTagCollection Specify the returned string when a block tag element has none children\n,\temptyTagCollection: '[]'\n\t//@method defineAttribute\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} object_name Name of the object used to accumulate the result of the code generation process\n\t//@param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes.\n\t// Besides notice that it can also be a piece of code\n\t//@return {String}\n,\tdefineAttribute: function (code_generation_context, object_name, property_name)\n\t{\n\t\t'use strict';\n\n\t\t//This is a simple hack to avoid having to create a new plugin just for this\n\t\tif (property_name === '\"class\"')\n\t\t{\n\t\t\tproperty_name = '\"className\"';\n\t\t\tcode_generation_context.keyName = 'className';\n\t\t}\n\n\t\treturn object_name + '['+property_name+']=\"\";';\n\t}\n\t//@method accumulateFinalAttributesResult Wrap up the final result after all attributes were converted to code\n\t//@param {CodeGenerationContext} attributes_result\n\t//@param {String} code_generation_context\n\t//@return {String}\n,\taccumulateFinalAttributesResult: function (code_generation_context, attributes_result)\n\t{\n\t\t'use strict';\n\n\t\tif (attributes_result)\n\t\t{\n\t\t\treturn '(function (){var '+code_generation_context.objectName+' = {}; ' + attributes_result + 'return '+code_generation_context.objectName+';})()';\n\t\t}\n\t\treturn 'null';\n\t}\n\t//@method setPropertysValue\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} property_definition String generated by the invocation of the method defineProperty\n\t//@param {String} property_accumulated_values Result of the code generation process applied to all the properties value\n\t//@return {String}\n,\tsetAttributeValue: function (code_generation_context, property_definition,  property_accumulated_values)\n\t{\n\t\t'use strict';\n\n\t\treturn property_definition + property_accumulated_values;\n\t}\n\t//@method accumulatePropertysValue\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} object_name Name of the object used to accumulate the result of the code generation process\n\t//@param {String} property_value Value of the property to set\n\t//@return {String}\n,\taccumulateAttributeValue: function (code_generation_context, object_name, property_value)\n\t{\n\t\t'use strict';\n\n\t\treturn object_name + '[\"'+code_generation_context.keyName+'\"]+=' + property_value +';';\n\t}\n\t//@method defineBlockTag\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} attributes_result Result of generating the code to all of the tag attributes\n\t//@param {String} children_result Accumulated result for all tag's children\n\t//@return {String}\n,\tdefineBlockTag: function (code_generation_context, tag_type, attributes_result, children_result)\n\t{\n\t\t'use strict';\n\n\t\treturn 'reactCreateElementWrapper(\"' + tag_type + '\",'+ attributes_result + (children_result !== this.emptyTagCollection ? ',' + children_result : '')+')';\n\t}\n\t//@method defineSingleTag\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} attributes_result Result of generating the code to all of the tag attributes\n\t//@return {String}\n,\tdefineSingleTag: function (code_generation_context, tag_type, attributes_result)\n\t{\n\t\t'use strict';\n\n\t\treturn 'reactCreateElementWrapper(\"' + tag_type + '\",'+ attributes_result+')';\n\t}\n\t//@method defineTextTag\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} text Take into account that this variable can contain code to be evaluated!\n\t//@return {String}\n,\tdefineTextTag: function (code_generation_context, text)\n\t{\n\t\t'use strict';\n\n\t\treturn text;\n\t}\n\t//@method accumulateFinalTagsResult Wrap up the final result get after all tags were converted to code. Please notice that at this point the string code\n\t//passed in generation_result parameter contains the entire resulting code\n\t//@param {CodeGenerationOptions} options\n\t//@param {CodeGenerationResult} geneation_result\n\t//@return {geneation_result}\n,\taccumulateFinalTagsResult: function (options, geneation_result)\n\t{\n\t\t'use strict';\n\n\t\tif (!options.notGenerateContext)\n\t\t{\n\t\t\tvar deps = geneation_result.contextName + (geneation_result.externalDependencies.length > 0 ? ',' +geneation_result.externalDependenciesObjectName : '' );\n\n\t\t\tgeneation_result.value = this._removeBrackets(geneation_result.value);\n\n\t\t\tgeneation_result.value =\n\t\t\t\t'function ('+deps+') { return React.createClass({ render: function () { '+reactCreateElementWrapper.toString()+' return ' + geneation_result.value + '; }});}';\n\t\t}\n\n\t\treturn geneation_result;\n\t}\n\n\t//@method _removeBrackets Auxiliary method to remove bracket generated by the fist call to the Tags iteration method (iterateOverTagNodes)\n\t//@param {String} code Code to clean\n\t//@return {String}\n,\t_removeBrackets: function (code)\n\t{\n\t\t'use strict';\n\n\t\tif (code.indexOf('[') === 0)\n\t\t{\n\t\t\tcode = code.substr(1);\n\t\t}\n\t\tif (code.indexOf(']', code.length - 1) !== -1)\n\t\t{\n\t\t\tcode = code.substr(0, code.length -1);\n\t\t}\n\t\treturn code;\n\t}\n};\n\nfunction reactCreateElementWrapper (tag_type, attributes, children)\n{\n\tvar params = children || [];\n\tparams.unshift(tag_type, attributes);\n\n\treturn React.createElement.apply(React.createElement, params);\n}\n\nmodule.exports = adapter;\n\n//@filename {Foo} fileName ./lib/Adapters/virtualDOMAdapter.js\n\n//@module blueHTML.Adapters\n//@class Adapter\nvar adapter = {\n\t//@property {String} Name Stringn that identify each adapter\n\tname: 'VD'\n\t//@property {String} emptyTagCollection Specify the returned string when a block tag element has none children\n,\temptyTagCollection: '[]'\n\t//@method defineAttribute\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} object_name Name of the object used to accumulate the result of the code generation process\n\t//@param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes.\n\t// Besides notice that it can also be a piece of code\n\t//@return {String}\n,\tdefineAttribute: function (code_generation_context, object_name, property_name)\n\t{\n\t\t'use strict';\n\n\t\treturn object_name + '['+property_name+']=\"\";';\n\t}\n\t//@method accumulateFinalAttributesResult Wrap up the final result get after all attributes were converted to code\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} attributes_result\n\t//@return {String}\n,\taccumulateFinalAttributesResult: function (code_generation_context, attributes_result)\n\t{\n\t\t'use strict';\n\n\t\tif (attributes_result)\n\t\t{\n\t\t\treturn '(function (){var '+code_generation_context.objectName+' = {}; ' + attributes_result + 'return {attributes: '+code_generation_context.objectName+'};})()';\n\t\t}\n\t\treturn '{}';\n\t}\n\t//@method setPropertysValue\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} property_definition String generated by the invocation of the method defineProperty\n\t//@param {String} property_accumulated_values Result of the code generation process applied to all the properties value\n\t//@return {String}\n,\tsetAttributeValue: function (code_generation_context, property_definition,  property_accumulated_values)\n\t{\n\t\t'use strict';\n\n\t\treturn property_definition + property_accumulated_values;\n\t}\n\t//@method accumulatePropertysValue\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} object_name Name of the object used to accumulate the result of the code generation process\n\t//@param {String} property_value Value of the property to set\n\t//@return {String}\n,\taccumulateAttributeValue: function (code_generation_context, object_name, property_value)\n\t{\n\t\t'use strict';\n\n\t\treturn object_name + '[\"'+code_generation_context.keyName+'\"]+=' + property_value +';';\n\t}\n\t//@method defineBlockTag\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} attributes_result Result of generating the code to all of the tag attributes\n\t//@param {String} children_result Accumulated result for all tag's children\n\t//@return {String}\n,\tdefineBlockTag: function (code_generation_context, tag_type, attributes_result, children_result)\n\t{\n\t\t'use strict';\n\n\t\treturn 'h(\"' + tag_type + '\",'+ attributes_result +',' + children_result + ')';\n\t}\n\t//@method defineSingleTag\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} attributes_result Result of generating the code to all of the tag attributes\n\t//@return {String}\n,\tdefineSingleTag: function (code_generation_context, tag_type, attributes_result)\n\t{\n\t\t'use strict';\n\n\t\treturn 'h(\"' + tag_type + '\",'+ attributes_result +',[])';\n\t}\n\t//@method defineTextTag\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {String} text Take into account that this variable can contain code to be evaluated!\n\t//@return {String}\n,\tdefineTextTag: function (code_generation_context, text)\n\t{\n\t\t'use strict';\n\n\t\treturn text;\n\t}\n\t//@method accumulateFinalTagsResult Wrap up the final result get after all tags were converted to code. Please notice that at this point the string code\n\t//passed in generation_result parameter contains the entire resulting code\n\t//@param {CodeGenerationOptions} options\n\t//@param {CodeGenerationResult} geneation_result\n\t//@return {geneation_result}\n,\taccumulateFinalTagsResult: function (options, geneation_result)\n\t{\n\t\t'use strict';\n\n\t\tif (!options.notGenerateContext)\n\t\t{\n\t\t\tvar deps = geneation_result.contextName + (geneation_result.externalDependencies.length > 0 ? ',' +geneation_result.externalDependenciesObjectName : '' );\n\t\t\tgeneation_result.value = 'function ('+deps+') { return ' + geneation_result.value + ';}';\n\t\t}\n\n\t\treturn geneation_result;\n\t}\n};\n\n//@class VirtualDOMAdapter @extend Adapter\nmodule.exports = adapter;\n\n//@filename {Foo} fileName ./lib/codeGenerator.Attributes.js\n\n//@module blueHTML\nvar _ = require('underscore')\n,\tcodeGeneratorBase = require('./codeGenerator.Base');\n\n//@class CodeGenerator\nmodule.exports = {\n\n\n\t//@method concatenateAttributeNodes Given a list of ast nodes, generate the concatenated string that represent the result of applying all the action specified in all the nodes\n\t//@param {Array<AttributeASTNode>} nodes List of node to concatenate\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\tconcatenateAttributeNodes: function (nodes, code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar self = this\n\t\t,\tis_setting_value = code_generation_context.isSettingValue;\n\n\t\tnodes = _.isArray(nodes) ? nodes : [nodes];\n\n\t\treturn _.reduce(nodes, function (acc, ast_node)\n\t\t{\n\t\t\tcode_generation_context.astNode = ast_node;\n\n\t\t\tast_node = codeGeneratorBase.beforeAttributeHandlerRetrieved.execute(ast_node, code_generation_context);\n\n\t\t\tvar handler_function = self.getNodeHandle(ast_node)\n\t\t\t,\tcurrent_result = '';\n\n\t\t\tast_node = codeGeneratorBase.beforeAttributeHandlerExecuted.execute(ast_node, code_generation_context, {handler: handler_function});\n\n\t\t\tcurrent_result = handler_function.call(self, code_generation_context);\n\t\t\tacc += current_result;\n\t\t\tcode_generation_context.isSettingValue = is_setting_value;\n\n\t\t\tast_node = codeGeneratorBase.afterAttributeHandlerExecuted.execute(ast_node\n\t\t\t,\tcode_generation_context\n\t\t\t,\t{\n\t\t\t\t\tacummulatedValue: acc\n\t\t\t\t,\tcurrentResult: current_result\n\t\t\t\t});\n\n\t\t\treturn acc;\n\t\t}, '');\n\t},\n\n\t//@method parseAttributes Internal method call when any attributes string need to be parsed. This method delegate the parsing task to the Attributes Parser Manager\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\tparseAttributes: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tcode_generation_context.astNode = codeGeneratorBase.beforeAttributeCodeGeneration.execute(code_generation_context.astNode, code_generation_context);\n\n\t\t//@class CodeGenerationContext\n\t\t//@property {Boolean} isSettingValue Indicate if in the current context the value of a property is being set or just the property itself\n\t\tcode_generation_context.isSettingValue = false;\n\t\t//@property {String} objectName Name of the object where all the properties are added. Property used in the context of the Attributes code generation.\n\t\tcode_generation_context.objectName = this.options.attributeObjectName;\n\t\t//@property {String} keyName Property used in the context of the Attributes code generation to indicate the name of the property being generated\n\t\tcode_generation_context.keyName = '';\n\t\t//@property {Boolean} isSettingAttributes. Property used in the context of the Attributes code generation. Falsy otherwise\n\t\tcode_generation_context.isSettingAttributes = true;\n\t\t//@class CodeGenerator\n\n\t\tvar result = ''\n\t\t,\toriginal_ast_node = code_generation_context.astNode\n\t\t,\tadapter = code_generation_context.adapter\n\t\t,\tattributes_ast = code_generation_context.astNode.attributes;\n\n\t\tif (attributes_ast.length)\n\t\t{\n\t\t\tresult = adapter.accumulateFinalAttributesResult.call(adapter, code_generation_context, this.concatenateAttributeNodes(attributes_ast, code_generation_context));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = adapter.accumulateFinalAttributesResult.call(adapter, code_generation_context, '');\n\t\t}\n\n\t\tcode_generation_context.isSettingValue = null;\n\t\tcode_generation_context.objectName = null;\n\t\tcode_generation_context.keyName = null;\n\t\tcode_generation_context.astNode = original_ast_node;\n\t\tcode_generation_context.isSettingAttributes = null;\n\n\t\tresult = codeGeneratorBase.afterAttributeCodeGeneration.execute(result, code_generation_context);\n\n\t\treturn result;\n\t},\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\tHTML \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t//@method keyValue Handle the parsing of all node of type keyValue\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\tkeyValue: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tcode_generation_context.isSettingValue = true;\n\t\tcode_generation_context.keyName = code_generation_context.astNode.key;\n\n\t\tvar key_name = code_generation_context.keyName\n\t\t,\tadapter = code_generation_context.adapter\n\t\t,\tkey_property_definition = adapter.defineAttribute.call(adapter, code_generation_context, code_generation_context.objectName,'\"'+ key_name+'\"')\n\t\t,\tkey_property_setting = this.concatenateAttributeNodes(code_generation_context.astNode.value, code_generation_context);\n\n\t\treturn adapter.setAttributeValue.call(adapter, code_generation_context, key_property_definition, key_property_setting);\n\t},\n\n\t//@method singleValue Handle the parsing of all node of type stringValue (Generally one single word used to set a property's value)\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\tsingleValue: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar adapter = code_generation_context.adapter\n\t\t,\tkey_name = code_generation_context.keyName;\n\n\t\tif (code_generation_context.isSettingValue)\n\t\t{\n\t\t\treturn adapter.accumulateAttributeValue.call(adapter, code_generation_context, code_generation_context.objectName,'\"'+ code_generation_context.astNode.value+'\"');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Single properties like checked or disable are parsed as singleValue\n\t\t\tvar key_property_definition = adapter.defineAttribute.call(adapter, code_generation_context, code_generation_context.objectName,'\"'+ key_name+'\"');\n\t\t\treturn adapter.setAttributeValue.call(adapter, code_generation_context, key_property_definition, '');\n\t\t}\n\t},\n\n\t//@method singleValue Handle the parsing of all node of type singleKey (Generally one single word used to set a property name)\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\tsingleKey: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar adapter = code_generation_context.adapter;\n\n\t\tif (code_generation_context.isSettingValue)\n\t\t{\n\t\t\tif ((code_generation_context.astNode.subType === 'extraSpaces' && code_generation_context.astNode.value !== '') ||\n\t\t\t\t\tcode_generation_context.astNode.subType !== 'extraSpaces')\n\t\t\t{\n\t\t\t\t//This case can happen because inside a handlebar code single expression are recognized as single key instead of single value!\n\t\t\t\treturn adapter.accumulateAttributeValue.call(adapter, code_generation_context, code_generation_context.objectName,'\"'+  code_generation_context.astNode.value+'\"');\n\t\t\t}\n\t\t}\n\t\telse if (code_generation_context.astNode.subType !== 'extraSpaces')\n\t\t{\n\t\t\tvar key_property_definition = adapter.defineAttribute.call(adapter, code_generation_context, code_generation_context.objectName, '\"'+ code_generation_context.astNode.value+'\"');\n\t\t\treturn adapter.setAttributeValue.call(adapter, code_generation_context, key_property_definition, '');\n\t\t}\n\t\treturn '';\n\t},\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\tHANDLEBARS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\t//@method handlebarsATTRSINGLEEVALUATION Handle the parsing of all safe evaluation handlebars node\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsATTRSINGLEEVALUATION: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar expression = '_.escape(' + code_generation_context.currentContextName.value + '.' + code_generation_context.astNode.value + ')'\n\t\t,\tadapter = code_generation_context.adapter;\n\n\t\tif (code_generation_context.isSettingValue)\n\t\t{\n\t\t\treturn adapter.accumulateAttributeValue.call(adapter, code_generation_context, code_generation_context.objectName, expression);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar key_property_definition = adapter.defineAttribute.call(adapter, code_generation_context, code_generation_context.objectName, expression);\n\t\t\treturn adapter.setAttributeValue.call(adapter, code_generation_context, key_property_definition, '');\n\t\t}\n\t},\n\n\t//@method handlebarsATTRLOOKUPSINGLE Handle the parsing of all context lookup\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsATTRLOOKUPSINGLE: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar expression = '_.escape(' + this._getLookUpContextName(code_generation_context, code_generation_context.astNode) + ')'\n\t\t,\tadapter = code_generation_context.adapter;\n\n\t\tif (code_generation_context.isSettingValue)\n\t\t{\n\t\t\treturn adapter.accumulateAttributeValue.call(adapter, code_generation_context, code_generation_context.objectName, expression);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar key_property_definition = adapter.defineAttribute.call(adapter, code_generation_context, code_generation_context.objectName, expression);\n\t\t\treturn adapter.setAttributeValue.call(adapter, code_generation_context, key_property_definition, '');\n\t\t}\n\t},\n\n\t//@method handlebarsATTRUNSAFESINGLEEVALUATION Handle the parsing of all un-safe evaluation handlebars node\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsATTRUNSAFESINGLEEVALUATION: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar expression = code_generation_context.currentContextName.value + '.' + code_generation_context.astNode.value\n\t\t,\tadapter = code_generation_context.adapter;\n\n\t\tif (code_generation_context.isSettingValue)\n\t\t{\n\t\t\treturn adapter.accumulateAttributeValue.call(adapter, code_generation_context, code_generation_context.objectName, expression);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar key_property_definition = adapter.defineAttribute.call(adapter, code_generation_context, code_generation_context.objectName, expression);\n\t\t\treturn adapter.setAttributeValue.call(adapter, code_generation_context, key_property_definition, '');\n\t\t}\n\t},\n\n\t//@method handlebarsATTRREFERENCEEVALUATION Handle the parsing of safe reference evaluation handlebar nodes\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsATTRREFERENCEEVALUATION: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar property_name = code_generation_context.astNode.value.trim().substr(1)\n\t\t,\texpression = ''\n\t\t,\tadapter = code_generation_context.adapter;\n\n\t\tif (code_generation_context.currentContextName[property_name])\n\t\t{\n\t\t\texpression = ' _.escape(' + code_generation_context.currentContextName.contextName + '.' + property_name + ')';\n\n\t\t\tif (code_generation_context.isSettingValue)\n\t\t\t{\n\t\t\t\tconsole.log('ATTRIBUTES CODE GENERATION <TEST> This case is not tested in out unit tests');\n\t\t\t\treturn adapter.accumulateAttributeValue.call(adapter, code_generation_context, code_generation_context.objectName, expression);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//This case is currently not supported by handlebarsX\n\t\t\t\tvar key_property_definition = adapter.defineAttribute.call(adapter, code_generation_context, code_generation_context.objectName, expression);\n\t\t\t\treturn adapter.setAttributeValue.call(adapter, code_generation_context, key_property_definition, '');\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(code_generation_context.astNode, 'Invalid safe reference evaluation');\n\t\tthrow new Error('Invalid safe reference evaluation.');\n\t},\n\n\t//@method handlebarsATTRIF Handle the parsing of all IF handlebars node\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsATTRIF: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar ast_node = code_generation_context.astNode\n\t\t,\tresult = 'if ('+this._handlebarsEvaluateCondition(code_generation_context, ast_node.condition)+') {';\n\n\t\tif (!ast_node.ifBody)\n\t\t{\n\t\t\tthrow new Error('Invalid if statement. An IF body is require: ' + JSON.stringify(ast_node));\n\t\t}\n\n\t\tresult += this.concatenateAttributeNodes(ast_node.ifBody, code_generation_context);\n\n\t\tif (ast_node.elseBody.length)\n\t\t{\n\t\t\t//there could be values that only returns empty string, like the extra added spaces.\n\t\t\tvar aux = this.concatenateAttributeNodes(ast_node.elseBody, code_generation_context);\n\t\t\tif (aux)\n\t\t\t{\n\t\t\t\tresult += '} else {';\n\t\t\t\tresult += aux;\n\t\t\t}\n\t\t}\n\n\t\tresult += '}';\n\t\treturn result;\n\t},\n\n\t//@method handlebarsATTREACH Handle the parsing of all EACHs handlebars node\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsATTREACH: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar ast_node = code_generation_context.astNode\n\t\t,\titerator_variable_name = this._generateUniqueId('eachIterator')\n\t\t,\titerator_index = iterator_variable_name+'Index'\n\t\t,\teach_context_name = this._generateUniqueId('contextName')\n\t\t,\titerator_name = this._handlebarsEvaluateCondition(code_generation_context, ast_node.iterator)\n\t\t,\tresult = ''\n\t\t,\teach_context = {\n\t\t\t\tvalue: iterator_variable_name\n\t\t\t,\tfirst: iterator_index + ' === 0'\n\t\t\t,\tlast: iterator_index + ' === ('+iterator_name+'.length - 1)'\n\t\t\t,\tindex: iterator_index\n\t\t\t,\tcontextName: each_context_name\n\t\t\t};\n\n\t\t//reduce/EACH header\n\t\tresult = '_.each( '+ iterator_name +', function ('+ iterator_variable_name+','+iterator_index+') {';\n\t\t//new context definition\n\t\tresult += this._serializeContext(each_context, each_context_name, each_context.value);\n\n\t\t//adapt context default value. It is needed to add the context name to the serialized context value\n\t\teach_context.value = each_context_name + '.' + each_context.value;\n\t\tcode_generation_context.contextStack.push(code_generation_context.currentContextName);\n\t\tcode_generation_context.currentContextName = each_context;\n\n\t\tresult += this.concatenateAttributeNodes(ast_node.eachBody, code_generation_context);\n\t\tresult += '});';\n\n\t\tcode_generation_context.currentContextName = code_generation_context.contextStack.pop();\n\n\t\t//TODO Give support for ELSE statement in EACH iterators!!!\n\n\t\t// if (ast_node.elseBody.length)\n\t\t// {\n\t\t// \tresult += '} else {'\n\t\t// \tresult += this.concatenateAttributeNodes(ast_node.elseBody, code_generation_context, true);\n\t\t// }\n\t\treturn result;\n\t},\n\n\t//@method handlebarsATTRUNLESS Handle the parsing of all UNLESS handlebars node\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsATTRUNLESS: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar ast_node = code_generation_context.astNode\n\t\t,\tresult = 'if (!'+this._handlebarsEvaluateCondition(code_generation_context, ast_node.condition)+') {';\n\n\t\tif (!ast_node.unlessBody)\n\t\t{\n\t\t\tthrow new Error('Invalid if statement. An UNLESS body is require: ' + JSON.stringify(ast_node));\n\t\t}\n\n\t\tresult += this.concatenateAttributeNodes(ast_node.unlessBody, code_generation_context);\n\n\t\tif (ast_node.elseBody)\n\t\t{\n\t\t\tresult += '} else {';\n\t\t\tresult += this.concatenateAttributeNodes(ast_node.elseBody, code_generation_context);\n\t\t}\n\n\t\tresult += '}';\n\t\treturn result;\n\t},\n};\n\n//@filename {Foo} fileName ./lib/codeGenerator.Base.js\n\n//@module blueHTML\n'use strict';\n\nvar handlebars_parser = require('handlebars-ex')\n,\tHookContainer = require('./hookContainer')\n,\t_ = require('underscore');\n\n//@class CodeGenerator Class responsible to call the Handlebars parsers and from that result generate Virtual-DOM code\nmodule.exports = (function ()\n{\n\t//@class CodeGenerationOptions\n\tvar default_parsing_options = {\n\t\t\t//@property {ContextContainer} contextName Name of the initial context when running the returned string code. Default value: 'ctx'\n\t\t\tcontextName: {\n\t\t\t\tvalue: 'ctx'\n\t\t\t}\n\t\t\t//@property {String} variableName Name of the variable used to accumulate all virtual dom nodes.\n\t\t,\tvariableName: 'children'\n\t\t\t//@property {Boolean} allowMultiplesFathers\n\t\t,\tallowMultiplesFathers: false\n\t\t\t//@property {Sring} attributeObjectName\n\t\t,\tattributeObjectName: 'obj'\n\t\t\t//@property {Sring} externalDependenciesObjectName\n\t\t,\texternalDependenciesObjectName: 'external_dependencies'\n\t\t};\n\n\t//@method codeGenerator\n\t//@constructor\n\t//@return {Void}\n\tfunction codeGenerator ()\n\t{\n\t\t/*jshint validthis:true */\n\t\tthis._UNIQUE_ID_COUNTER = 0;\n\t}\n\n\t//@method generateCode Public method to generate code\n\t//@param {String} string_hx HTML/HandlebarX code to parse\n\t//@param {CodeGenerationOptions} options\n\t//@return {CodeGenerationResult}\n\tcodeGenerator.prototype.generateCode = function (string_hx, options)\n\t{\n\t\tthis.options = _.defaults(options || {}, default_parsing_options);\n\n\t\tif (!this.options.adapter)\n\t\t{\n\t\t\tthrow new Error('Invalid codeGenerator options. Please make sure an adapter is set');\n\t\t}\n\n\t\tvar result = this._parse(string_hx)\n\t\t,\tadapter = this.options.adapter;\n\n\t\tif (result.value.indexOf('[') === 0)\n\t\t{\n\t\t\tresult.value = result.value.substr(1);\n\t\t}\n\t\tif (result.value.indexOf(']', result.value.length - 1) !== -1)\n\t\t{\n\t\t\tresult.value = result.value.substr(0, result.value.length -1);\n\t\t}\n\n\t\treturn adapter.accumulateFinalTagsResult.call(adapter, this.options, result);\n\t};\n\n\t//@method _parse Internal method that parse the given string and generates the corresponding a virtual-dom string\n\t//@param {String} string HTML/Handlebar code to parse\n\t//@return {CodeGenerationResult}\n\tcodeGenerator.prototype._parse = function (string)\n\t{\n\t\tvar\tnodes_ast\n\t\t//@class CodeGenerationResult\n\t\t,\tcommunication_result = {\n\t\t\t\t//@property {String} contextName\n\t\t\t\tcontextName: this.options.contextName.value\n\t\t\t\t//@property {String} value Final string result\n\t\t\t,\tvalue: ''\n\t\t\t\t//@property {Arra<String>} externalDependencies General purpose array to be used by plugins to add any external dependency\n\t\t\t,\texternalDependencies: []\n\t\t\t\t//@property {String} externalDependenciesObjectName Name of the object that will carry all external dependencies\n\t\t\t,\texternalDependenciesObjectName: this.options.externalDependenciesObjectName\n\t\t\t}\n\t\t//@class CodeGenerationContext This class holds all the information and data used during the code generation process\n\t\t,\tcode_generation_context = {\n\t\t\t\t//@property {NodeASTNode} astNode Current node being processed\n\t\t\t\tastNode: {}\n\t\t\t\t//property {ContextContainer} currentContextName\n\t\t\t,\tcurrentContextName: this.options.contextName\n\t\t\t\t//@property {Array<ContextContainer>} contextStack Stack where all context names are saved. Used in functions like handlebars EACH that change the current context name.\n\t\t\t,\tcontextStack: []\n\t\t\t\t//@property {String} variableName Name of the variable that accumulate all virtual-dom elements\n\t\t\t,\tvariableName: this.options.variableName\n\t\t\t\t//@param {Boolean} isInsideContext Indicate if this function is invoked being inside a new execution context.\n\t\t\t\t// This means, in case it is true, that the result must be concatenated with the current variable name.\n\t\t\t,\tisInsideContext: false\n\t\t\t\t//@property {String} externalDependenciesObjectName Name of the object that will carry all external dependencies\n\t\t\t,\texternalDependenciesObjectName: this.options.externalDependenciesObjectName\n\t\t\t\t//@property {Adapter} adapter\n\t\t\t,\tadapter: this.options.adapter\n\t\t\t};\n\t\t//@class CodeGenerator\n\n\t\tstring = codeGenerator.beforeTagCodeGeneration.execute(string, code_generation_context);\n\n\t\tnodes_ast = handlebars_parser.parse(string);\n\n\t\tif (nodes_ast.length > 1 && !this.options.allowMultiplesFathers)\n\t\t{\n\t\t\tthrow new Error('Invalid handlebars template. Please make sure there is only one parent node!');\n\t\t}\n\n\t\tcommunication_result.value = this.iterateOverTagNodes(nodes_ast, code_generation_context, false);\n\n\t\tcommunication_result = codeGenerator.afterTagCodeGeneration.execute(communication_result, code_generation_context);\n\n\t\treturn communication_result;\n\t};\n\n\t//@method getNodeHandle Auxiliary method that given a node, returns the method (of this class) that will handle/parse it\n\t// Please notice that the searched function must fulfill the criteria based on the name of the type of the ast node\n\t//@param {NodeASTNode} ast_node Node used to look a handle for\n\t//@return {Function<CodeGenerationContext, Boolean, String>}\n\tcodeGenerator.prototype.getNodeHandle = function (ast_node)\n\t{\n\t\tvar fn;\n\n\t\tif (ast_node.type === 'handlebars' && (ast_node.subType === 'GENERICSINGLE' || ast_node.subType === 'ATTRGENERICSINGLE'))\n\t\t{\n\t\t\tfn = _.isFunction(this['single' + ast_node.value]) ? this['single' + ast_node.value] :\n\t\t\t\t\t_.isFunction(this['singleInstance' + ast_node.value]) ? this.runtimeGenericSingleHandle :\n\t\t\t\t\tnull;\n\t\t}\n\t\telse if (ast_node.type === 'handlebars' && ast_node.subType === 'GENERICBLOCK')\n\t\t{\n\t\t\tfn = _.isFunction(this['block' + ast_node.openTag]) ? this['block' + ast_node.openTag] :\n\t\t\t\t\t_.isFunction(this['blockInstance' + ast_node.openTag]) ? this.runtimeGenericBlockHandle :\n\t\t\t\t\tnull;\n\t\t}\n\t\telse if (ast_node.type === 'handlebars')\n\t\t{\n\t\t\tfn = this['handlebars' + ast_node.subType];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfn = this[ast_node.type];\n\t\t}\n\n\t\tif (!fn)\n\t\t{\n\t\t\tconsole.log(ast_node);\n\t\t}\n\n\t\treturn fn;\n\t};\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\tPLUGINS DEFINITION\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t//@property {HookContainer} beforeAttributeHandlerRetrieved Static plugin property invoked before the attributes handlebars handler is detected/retrieved.\n\t//Aim: Edit the selected attribute AST Node before being used to detect the handler\n\t//Its invocation has the following signature: Function<AttributeASTNode, CodeGenerationContext,\tAttributeASTNode> where the last value is the optional return one.\n\tcodeGenerator.beforeAttributeHandlerRetrieved = new HookContainer();\n\n\t//@property {HookContainer} beforeAttributeHandlerExecuted Static plugin property invoked before the attributes handlebars handler is executed\n\t//Aim: Edit the selected attribute AST node before being used by the selected handle and wrap the selected handler function\n\t//Its invocation has the following signature: Function<AttributeASTNode, CodeGenerationContext, Object<handler:function>, AttributeASTNode> where the last value is the optional return one.\n\tcodeGenerator.beforeAttributeHandlerExecuted = new HookContainer();\n\t//@property {HookContainer} afterAttributeHandlerExecuted Static plugin property invoked after the attributes handlebars handler is executed\n\t//Aim: Access the accumulated attribute generated code up to the moment, access the result of the function handler and add another step to edit the selected attribute AST node\n\t//Its invocation has the following signature: Function<AttributeASTNode, CodeGenerationContext, Object<acummulatedValue:String, currentResult:String>, AttributeASTNode> where the last value is the optional return one.\n\tcodeGenerator.afterAttributeHandlerExecuted = new HookContainer();\n\n\t//@property {HookContainer} beforeAttributeCodeGeneration Static plugin property invoked when at the beginning of the attributes code generation process for each tag node.\n\t//Aim: Access the entire Tag node that contains the attributes sub-tree, and to initialize plugin's state related with the attributes code generation\n\t//Its invocation has the following signature: Function<AttributeASTNode, CodeGenerationContext, AttributeASTNode> where the last value is the optional return one.\n\tcodeGenerator.beforeAttributeCodeGeneration = new HookContainer();\n\t//@property {HookContainer} afterAttributeCodeGeneration Static plugin property invoked when at the end of the attributes code generation process for each tag node.\n\t//Aim: Access/Edit the entire result of attributes code generation, also to clean up any plugin's state\n\t//Its invocation has the following signature: Function<String, CodeGenerationContext, String> where the last value is the optional return one.\n\tcodeGenerator.afterAttributeCodeGeneration = new HookContainer();\n\n\t//@property {HookContainer} beforeTagCodeGeneration Static plugin property invoked at the beginning of the entire code generation process\n\t//Aim: Access/Edit the entire string template and initalize any plugin state\n\t//Its invocation has the following signature: Function<String, CodeGenerationContext, String> where the last value is the optional return one.\n\tcodeGenerator.beforeTagCodeGeneration = new HookContainer();\n\t//@property {HookContainer} afterTagCodeGeneration Static plugin property invoked at the end of the entire code generation process\n\t//Aim: Access/Edit the entire code generation process result\n\t//Its invocation has the following signature: Function<CodeGenerationResult, CodeGenerationContext, CodeGenerationResult> where the last value is the optional return one.\n\tcodeGenerator.afterTagCodeGeneration = new HookContainer();\n\n\t//@property {HookContainer} afterTagEachContextCreation Static plugin property invoked after handlebars 'EACH' tags context is created\n\t//Aim: Access the current AST node\n\t//Its invocation has the following signature: Function<NodeASTNode, CodeGenerationContext, NodeASTNode> where the last value is the optional return one. It is not recommend to return anything in this plugin.\n\tcodeGenerator.afterTagEachContextCreation = new HookContainer();\n\t//@property {HookContainer} afterTagEachContextCreation Static plugin property invoked before handlebars 'EACH' tags context is created\n\t//Aim: Augment the EACH context\n\t//Its invocation has the following signature: Function<HandlebarsEACHContext, CodeGenerationContext, HandlebarsEACHContext> where the last value is the optional return one.\n\tcodeGenerator.beforeTagEachContextCreation = new HookContainer();\n\n\treturn codeGenerator;\n})();\n\n//@filename {Foo} fileName ./lib/codeGenerator.CustomHelpers.js\n\n//@module blueHTML\nvar _ = require('underscore');\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\tTAGS \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n//@class CodeGenerator\nmodule.exports = {\n\n\t//@method _joinExternalFunctionParameters Internal method to join parameters used by external functions\n\t//@param {Array<ParameterNode>} parameters\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\t_joinExternalFunctionParameters: function (parameters, code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar self = this;\n\n\t\t//TODO TAKE INTO ACCOUNT THAT PARAMETERS CAN BE REFERENCE VALUES (@index)\n\t\treturn _.reduce(parameters, function (acc, param)\n\t\t{\n\t\t\tswitch (param.subType) {\n\t\t\t\tcase 'SIMPLEVALUE':\n\t\t\t\t\tacc += ',' + param.value;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'LOOKUPSINGLE':\n\t\t\t\t\tacc += ',' + self._getLookUpContextName(code_generation_context, param);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SINGLEEVALUATION':\n\t\t\t\t\tif ((+param.value).toString() === param.value)\n\t\t\t\t\t{\n\t\t\t\t\t\t//This is the case of numbers\n\t\t\t\t\t\tacc += ',' + param.value;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tacc += ',' + code_generation_context.currentContextName.value + '.' + param.value;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tacc += ',' + param.value;\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, '');\n\t},\n\n\t//@method runtimeGenericSingleHandle This method converts all passed in function that represent extra helpers to string in a safe way\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {Function<CodeGenerationContext, Boolean, String>}\n\truntimeGenericSingleHandle: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar fn = this['singleInstance' + code_generation_context.astNode.value].toString()\n\t\t,\tresult = '(function(){var fn = '+fn+'; return fn.call(this'+ this._joinExternalFunctionParameters(code_generation_context.astNode.parameters, code_generation_context)+'); })()';\n\n\t\tif (code_generation_context.isSettingAttributes)\n\t\t{\n\t\t\tif (code_generation_context.isSettingValue)\n\t\t\t{\n\t\t\t\treturn code_generation_context.objectName + '[\"'+code_generation_context.keyName+'\"]+=' + result +';';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn code_generation_context.objectName + '['+result+']=\"\";';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn code_generation_context.isInsideContext ?  code_generation_context.variableName + '=' + code_generation_context.variableName + '.concat(['+result+']);' : result;\n\t\t}\n\t},\n\n\t//@method runtimeGenericBlockHandle This method converts all passed in function that represent extra helpers to string in a safe way\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {Function<CodeGenerationContext, Boolean, String>}\n\truntimeGenericBlockHandle: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar fn = this['blockInstance' + code_generation_context.astNode.openTag].toString()\n\t\t,\tresult = '(function(){var fn = '+fn+'; return fn.call(this'+ this._joinExternalFunctionParameters(code_generation_context.astNode.parameters, code_generation_context)+'); })()';\n\n\t\treturn code_generation_context.isInsideContext ?  code_generation_context.variableName + '=' + code_generation_context.variableName + '.concat(['+result+']);' : result;\n\t}\n};\n\n//@filename {Foo} fileName ./lib/codeGenerator.Tags.js\n\n//@module blueHTML\nvar _ = require('underscore')\n,\tcodeGeneratorBase = require('./codeGenerator.Base');\n\n//@class CodeGenerator\nmodule.exports = {\n\n\t//@method iterateOverTagNodes Given a list of ast nodes, iterate over them and returns a string that represent its union.\n\t//@param {Array<NodeASTNode>} nodes List of nodes to iterate\n\t//@param {CodeGenerationContext} code_generation_context Current code generation context\n\t//@param {Boolean} parent_require_new_context Indicate if the parent, the function that calls this function, requires that the result be in another\n\t// execution context or not.\n\t//@return {String} Portion of code that group all the nodes passed in\n\titerateOverTagNodes: function (nodes, code_generation_context, parent_require_new_context)\n\t{\n\t\t'use strict';\n\n\t\tvar self = this\n\t\t,\thandle_function\n\t\t,\tresult = ''\n\t\t,\tvariableName = code_generation_context.variableName\n\n\t\t,\tthere_is_NO_handlebars = _.all(nodes, function (node)\n\t\t\t{\n\t\t\t\treturn node.type !== 'handlebars';\n\t\t\t});\n\n\t\tcode_generation_context.isInsideContext = parent_require_new_context || !there_is_NO_handlebars;\n\n\t\tif (nodes.length)\n\t\t{\n\t\t\tif (code_generation_context.isInsideContext)\n\t\t\t{\n\t\t\t\tresult = '(function () {';\n\t\t\t\tresult +=  'var '+variableName+ '=[];';\n\t\t\t\tresult += _.map(nodes, function (ast_node)\n\t\t\t\t{\n\t\t\t\t\tcode_generation_context.astNode = ast_node;\n\t\t\t\t\thandle_function = self.getNodeHandle(ast_node);\n\t\t\t\t\treturn handle_function.call(self, code_generation_context, true);\n\t\t\t\t}, '').join('');\n\n\t\t\t\tresult += 'return '+variableName+'; })()';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = '[' + _.map(nodes, function (ast_node)\n\t\t\t\t{\n\t\t\t\t\tcode_generation_context.astNode = ast_node;\n\t\t\t\t\tcode_generation_context.isInsideContext = false;\n\t\t\t\t\thandle_function = self.getNodeHandle(ast_node);\n\t\t\t\t\treturn handle_function.call(self, code_generation_context, false);\n\t\t\t\t}, '').join(',') + ']';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = _.isUndefined(code_generation_context.adapter.emptyTagCollection) ? '[]' : code_generation_context.adapter.emptyTagCollection;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\tHTML \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\t//@method htmlBlockNode Handle standard HTML blocks\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thtmlBlockNode: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar code_generation_context_clone = _.clone(code_generation_context)\n\t\t,\tattributes_result = this.parseAttributes(code_generation_context)\n\t\t,\tchildren_result = this.iterateOverTagNodes(code_generation_context.astNode.children, code_generation_context, true)\n\t\t,\tadapter = code_generation_context.adapter\n\t\t,\tvirtual_dom = adapter.defineBlockTag.call(adapter, code_generation_context_clone, code_generation_context_clone.astNode.openTag, attributes_result, children_result);\n\n\t\tif (code_generation_context_clone.isInsideContext)\n\t\t{\n\t\t\treturn this._concatenateTagValues(code_generation_context.variableName, virtual_dom, code_generation_context);\n\t\t}\n\t\treturn virtual_dom;\n\t},\n\n\t//@method htmlSingleNode Handle standard one liner HTML\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thtmlSingleNode: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar code_generation_context_clone = _.clone(code_generation_context)\n\t\t,\tattributes_result = this.parseAttributes(code_generation_context)\n\t\t,\tadapter = code_generation_context.adapter\n\t\t,\tvirtual_dom = adapter.defineSingleTag.call(adapter, code_generation_context_clone, code_generation_context_clone.astNode.tag, attributes_result);\n\n\t\tif (code_generation_context_clone.isInsideContext)\n\t\t{\n\t\t\treturn this._concatenateTagValues(code_generation_context.variableName, virtual_dom, code_generation_context);\n\t\t}\n\t\treturn virtual_dom;\n\t},\n\n\t//@method text Handle plain text inside the HTML document\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\ttext: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar adapter = code_generation_context.adapter\n\t\t,\tvirtual_dom = adapter.defineTextTag.call(adapter, code_generation_context, '\\'' + code_generation_context.astNode.value.replace(/'/g, \"\\\\'\")+ '\\'');\n\n\t\tif (code_generation_context.isInsideContext)\n\t\t{\n\t\t\treturn this._concatenateTagValues(code_generation_context.variableName, virtual_dom, code_generation_context);\n\t\t}\n\t\treturn virtual_dom;\n\t},\n\n\t//@method htmlComment Handle standard HTML comments\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thtmlComment: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\t//TODO MAKE A BETTER MANAGEMENT OF HTML COMMENT NODES!!\n\t\treturn '';\n\t},\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\tUTILS TAGS \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t//@method _concatenateValues Concatenate/Composite a bunch of results into the accumulator variable. Used when the conversion is done inside a new context.\n\t//@param {String} accumulator_variable_name Name of the variable than has all the results\n\t//@param {String} children_result Result to be appended\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {Boolean} are_children_array Indicate if the children_result param is an array or not. (If false children_result will be wrapper with '[' ']' characters)\n \t//@return {String}\n\t_concatenateTagValues: function (accumulator_variable_name, children_result, code_generation_context, are_children_array)\n\t{\n\t\t'use strict';\n\n\t\tvar adapter = code_generation_context.adapter;\n\n\t\tif (_.isFunction(adapter.concatenateTagValues))\n\t\t{\n\t\t\treturn adapter.concatenateTagValues.call(adapter, accumulator_variable_name, children_result, code_generation_context);\n\t\t}\n\n\t\tif (!are_children_array)\n\t\t{\n\t\t\tchildren_result = '['+children_result+']';\n\t\t}\n\n\t\treturn accumulator_variable_name + '='+ accumulator_variable_name + '.concat('+children_result+');';\n\t},\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\tHANDLEBARS \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\t//@method handlebarsSINGLECOMMENTS Handle the parsing of handlebar line comments\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsSINGLECOMMENTS: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\t//TODO Provide some support for handlebars comments\n\t\treturn '';\n\t},\n\n\t//@method handlebarsSAFEEVALUATION Handle the parsing of safe evaluation handlebar nodes\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsSAFEEVALUATION: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar adapter = code_generation_context.adapter\n\t\t,\tvirtual_dom = adapter.defineTextTag.call(adapter, code_generation_context, '_.escape('+ code_generation_context.currentContextName.value + '.'+ code_generation_context.astNode.value +')');\n\n\t\tif (code_generation_context.isInsideContext)\n\t\t{\n\t\t\treturn this._concatenateTagValues(code_generation_context.variableName, virtual_dom, code_generation_context);\n\t\t}\n\t\treturn virtual_dom;\n\t},\n\n\t//@method handlebarsUNSAFEEVALUATION Handle the parsing of unsafe evaluation handlebar nodes\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsUNSAFEEVALUATION: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar adapter = code_generation_context.adapter\n\t\t,\tvirtual_dom = adapter.defineTextTag.call(adapter, code_generation_context, '\"\"+' + code_generation_context.currentContextName.value + '.'+ code_generation_context.astNode.value );\n\n\t\tif (code_generation_context.isInsideContext)\n\t\t{\n\t\t\treturn this._concatenateTagValues(code_generation_context.variableName, virtual_dom, code_generation_context);\n\t\t}\n\t\treturn virtual_dom;\n\t},\n\n\t//@method handlebarsLOOKUPSINGLE Handle the parsing of single lookup variable evaluation\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsLOOKUPSINGLE: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar adapter = code_generation_context.adapter\n\t\t,\texpression = '_.escape('+ this._getLookUpContextName(code_generation_context, code_generation_context.astNode) + ')'\n\t\t,\tvirtual_dom = adapter.defineTextTag.call(adapter, code_generation_context, expression);\n\n\t\tif (code_generation_context.isInsideContext)\n\t\t{\n\t\t\treturn this._concatenateTagValues(code_generation_context.variableName, virtual_dom, code_generation_context);\n\t\t}\n\t\treturn virtual_dom;\n\t},\n\n\t//@method handlebarsSAFEREFERENCEEVALUATION Handle the parsing of safe reference evaluation handlebar nodes\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsSAFEREFERENCEEVALUATION: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar property_name = code_generation_context.astNode.value.trim().substr(1);\n\n\t\tif (code_generation_context.currentContextName[property_name])\n\t\t{\n\t\t\tvar adapter = code_generation_context.adapter\n\t\t\t,\texpression = '_.escape('+ code_generation_context.currentContextName.contextName + '.' + property_name+')'\n\t\t\t,\tvirtual_dom = adapter.defineTextTag.call(adapter, code_generation_context, expression);\n\n\t\t\tif (code_generation_context.isInsideContext)\n\t\t\t{\n\t\t\t\treturn this._concatenateTagValues(code_generation_context.variableName, virtual_dom, code_generation_context);\n\t\t\t}\n\t\t\treturn virtual_dom;\n\t\t}\n\n\t\tconsole.log(code_generation_context.astNode, 'Invalid safe reference evaluation');\n\t\tthrow new Error('Invalid safe reference evaluation.');\n\t},\n\n\t//@method handlebarsEACH Handle the parsing of each handlebar nodes\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsEACH: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\t code_generation_context.astNode = codeGeneratorBase.afterTagEachContextCreation.execute( code_generation_context.astNode, code_generation_context);\n\n\t\tvar ast_node = code_generation_context.astNode\n\t\t,\titerator_variable_name = this._generateUniqueId('eachIterator')\n\t\t,\titerator_index = iterator_variable_name+'Index'\n\t\t,\taccumulator_variable_name = this._generateUniqueId('eachAccumulator')\n\t\t,\teach_context_name = this._generateUniqueId('contextName')\n\t\t,\titerator_name = this._handlebarsEvaluateCondition(code_generation_context, ast_node.iterator)\n\t\t,\tresult = ''\n\t\t//@class HandlebarsEACHContext\n\t\t,\teach_context = {\n\t\t\t\t//@property {String} value\n\t\t\t\tvalue: iterator_variable_name\n\t\t\t\t//@property {String} first This string, when compiled will be converted to Boolean\n \t\t\t,\tfirst: iterator_index + ' === 0'\n\t\t\t\t//@property {String} last This string, when compiled will be converted to Boolean\n\t\t\t,\tlast: iterator_index + ' === ('+iterator_name+'.length - 1)'\n\t\t\t\t//@property {String} index This string, when compiled will be converted to Number\n\t\t\t,\tindex: iterator_index\n\t\t\t\t//@property {String} contextName\n\t\t\t,\tcontextName: each_context_name\n\n\t\t\t//This SHOULD NOT BE IN THE CORE, THIS OPTIONS MUST BE ADDED BY ONE EXTENSION!\n\t\t\t//I added here just to make it fast and easy :P\n\t\t\t,\tindexPlusOne: iterator_index + '+1'\n\t\t\t};\n\t\t\t//@class CodeGenerator\n\n\t\teach_context = codeGeneratorBase.beforeTagEachContextCreation.execute(each_context, code_generation_context);\n\n\t\t//reduce/EACH header\n\t\tresult = code_generation_context.variableName + '=' + code_generation_context.variableName + '.concat(' +\n\t\t\t'_.reduce( '+ iterator_name +', function ('+\n\t\t\t\t\taccumulator_variable_name+',' + iterator_variable_name+','+iterator_index+') {';\n\t\t//new context definition\n\t\tresult += this._serializeContext(each_context, each_context_name, each_context.value);\n\n\t\t//adapt context default value. It is needed to add the context name to the serialized context value\n\t\teach_context.value = each_context_name + '.' + each_context.value;\n\t\tcode_generation_context.contextStack.push(code_generation_context.currentContextName);\n\t\tcode_generation_context.currentContextName = each_context;\n\n\t\t// result += accumulator_variable_name +'='+ accumulator_variable_name +'.concat('+ this.iterateOverTagNodes(ast_node.eachBody, code_generation_context, true)+ ');';\n\t\tresult += this._concatenateTagValues(accumulator_variable_name, this.iterateOverTagNodes(ast_node.eachBody, code_generation_context, true), code_generation_context, true);\n\t\tresult += 'return ' + accumulator_variable_name;\n\t\tresult += '}, []));';\n\n\t\tcode_generation_context.currentContextName = code_generation_context.contextStack.pop();\n\n\t\t//TODO Give support for ELSE statement in EACH iterators!!!\n\n\t\t// if (ast_node.elseBody.length)\n\t\t// {\n\t\t// \tresult += '} else {'\n\t\t// \tresult += this.iterateOverTagNodes(ast_node.elseBody, code_generation_context, true);\n\t\t// }\n\t\treturn result;\n\t},\n\n\t//@method handlebarsIF Handle the parsing of IF handlebar nodes\n\t// Notice that the second param 'not_consider_context' is indeed being passed in to this function, it is just the it does not make sense to used,\n\t// as we always need to run any handlebars conversion in the context of a function, '(function () {}()'\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsIF: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar ast_node = code_generation_context.astNode\n\t\t,\tresult = 'if ('+ this._handlebarsEvaluateCondition(code_generation_context, ast_node.condition) +') {';\n\n\t\tresult += this._concatenateTagValues(code_generation_context.variableName, this.iterateOverTagNodes(ast_node.ifBody, code_generation_context, true), code_generation_context, true);\n\n\t\tif (ast_node.elseBody.length)\n\t\t{\n\t\t\tresult += '} else {';\n\t\t\tresult += code_generation_context.variableName + '=' + code_generation_context.variableName + '.concat('+\n\t\t\t\tthis.iterateOverTagNodes(ast_node.elseBody, code_generation_context, true) +');';\n\t\t}\n\t\tresult += '}';\n\t\treturn result;\n\t},\n\n\t//@method handlebarsUNLESS Handle the parsing of UNLESS handlebar nodes\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@return {String}\n\thandlebarsUNLESS: function (code_generation_context)\n\t{\n\t\t'use strict';\n\n\t\tvar ast_node = code_generation_context.astNode\n\t\t,\tresult = 'if (!'+this._handlebarsEvaluateCondition(code_generation_context, ast_node.condition) +') {';\n\n\t\tresult += this.iterateOverTagNodes(ast_node.unlessBody, code_generation_context, true);\n\n\t\tif (ast_node.elseBody.length)\n\t\t{\n\t\t\tresult += '} else {';\n\t\t\tresult += this.iterateOverTagNodes(ast_node.elseBody, code_generation_context, true);\n\t\t}\n\t\tresult += '}';\n\t\treturn result;\n\t}\n};\n\n\n//@filename {Foo} fileName ./lib/codeGenerator.Utils.js\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\tUTILS \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n//@module blueHTML\n//@class CodeGenerator\nmodule.exports = {\n\n\t//@method _generateUniqueId Internal method used to create unique identifiers. Copy of underscore.uniqueId. It is copy here in order to\n\t// control it's internal state.\n\t//@param {String?} prefix Optional prefix\n\t//@return {String}\n\t_generateUniqueId: function (prefix)\n\t{\n\t\t'use strict';\n\n\t\tvar id = ++this._UNIQUE_ID_COUNTER + '';\n\t\treturn prefix ? prefix + id : id;\n\t},\n\n\t//@method _serializeContext Internal method used to serialize a context object. This method is used by each handlebar block object that defines a new context. For example EACH\n\t// Notice that the presence of any property called contextName will NOT be included in the final result\n\t//@param {Object} context Any plain javascript object with one 'value' property\n\t//@param {String} variable_name Name of the object in the returned string\n\t//@param {String} value_name Name of the value property in the returned string\n\t//@return {String}\n\t_serializeContext: function (context, variable_name, value_name)\n\t{\n\t\t'use strict';\n\n\t\tvar result = 'var ' + variable_name + '= {'\n\t\t,\tprefix = '';\n\n\t\tfor (var key in context)\n\t\t{\n\t\t\tif (context.hasOwnProperty(key) && key !== 'contextName')\n\t\t\t{\n\t\t\t\tif (key === 'value')\n\t\t\t\t{\n\t\t\t\t\tresult += prefix + value_name + ':' + context[key];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult += prefix + key + ':' + context[key];\n\t\t\t\t}\n\n\t\t\t\tprefix = ',';\n\t\t\t}\n\t\t}\n\n\t\tresult += '};';\n\t\treturn result;\n\t},\n\n\t//@method _getLookUpContextName Internal method to find the context name in the case of look Ups\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {NodeASTNode} node\n\t//@return {String}\n\t_getLookUpContextName: function (code_generation_context, node)\n\t{\n\t\t'use strict';\n\n\t\t//We remove one as the length returns the amount of items in the array and we need the index\n\t\tvar number_of_elements_to_exclude = code_generation_context.contextStack.length - 1\n\t\t//We remove 2 because; 1 for the name of the variable inside the value array and 1 because the current context name is not the parsing context stack\n\t\t,\tinverted_index = node.value.length - 2\n\t\t,\tcontext_index = (number_of_elements_to_exclude - inverted_index) < 0 ? 0 : number_of_elements_to_exclude - inverted_index\n\t\t,\tselected_context_name = code_generation_context.contextStack[context_index] ? code_generation_context.contextStack[context_index].value : code_generation_context.currentContextName.value;\n\n\t\treturn selected_context_name + '.' + node.value[node.value.length - 1];\n\t},\n\n\t//@method _handlebarsEvaluateCondition Evaluates the condition of IFs, UNLESSs and EACHs. As these values can be single evaluation or lookups\n\t//@param {CodeGenerationContext} code_generation_context\n\t//@param {ConditionNode} condition\n\t//@return {String}\n\t_handlebarsEvaluateCondition: function (code_generation_context, condition)\n\t{\n\t\t'use strict';\n\n\t\tif (condition.subType === 'SINGLEEVALUATION' || condition.subType === 'ATTRSINGLEEVALUATION')\n\t\t{\n\t\t\treturn code_generation_context.currentContextName.value + '.' + condition.value;\n\t\t}\n\t\telse if (condition.subType === 'REFERENCEEVALUATION' || condition.subType === 'ATTRREFERENCEEVALUATION')\n\t\t{\n\t\t\tvar property_name = condition.value.trim().substr(1);\n\t\t\tif (code_generation_context.currentContextName[property_name])\n\t\t\t{\n\t\t\t\treturn code_generation_context.currentContextName.contextName + '.' + property_name;\n\t\t\t}\n\t\t\tconsole.log(condition, 'Invalid reference evaluation');\n\t\t\tthrow new Error('Invalid reference evaluation.');\n\t\t}\n\t\telse if (condition.subType === 'LOOKUPSINGLE' || condition.subType === 'ATTRLOOKUPSINGLE')\n\t\t{\n\t\t\treturn this._getLookUpContextName(code_generation_context, condition);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconsole.log(condition, 'Non supported evaluation!');\n\t\t\tthrow new Error('Non supported evaluation!');\n\t\t}\n\t}\n};\n\n//@filename {Foo} fileName ./lib/codeGenerator.js\n\n//@module blueHTML\nvar base = require('./codeGenerator.Base')\n,\tutils = require('./codeGenerator.Utils')\n,\ttags = require('./codeGenerator.Tags')\n,\tattributes = require('./codeGenerator.Attributes')\n,\tcustomHelpers = require('./codeGenerator.CustomHelpers')\n,\t_ = require('underscore');\n\n//@class CodeGenerator\nbase.prototype = _.extend(\n\t\tbase.prototype\n\t,\tutils\n\t,\ttags\n\t,\tattributes\n\t,\tcustomHelpers\n\t,\t{\n\t\t\t//@method addCustomHandler Add a new handlebars handler\n\t\t\t//@param {Function }\n\t\t\t//@return {Void}\n\t\t\taddCustomHandler: function (handlebars_handlers)\n\t\t\t{\n\t\t\t\t'use strict';\n\n\t\t\t\t_.extend(base.prototype, handlebars_handlers || {});\n\t\t\t}\n\t\t\t//@method installPlugin Install a plugin inside the code generator\n\t\t\t//@param {Plugin} plugin_container\n\t\t\t//@return {Void}\n\t\t,\tinstallPlugin: function (plugin_container)\n\t\t\t{\n\t\t\t\t'use strict';\n\n\t\t\t\t/*jshint -W030 */\n\t\t\t\tplugin_container && plugin_container.install && plugin_container.install.call(plugin_container, base);\n\t\t\t}\n\t\t}\n\t);\n\nmodule.exports = base;\n\n\n//@class Plugin\n//@method install Public method invoked by blueHTML when adding a new plugin.\n//@param {CodeGenerator} codeGenerator\n//@return {Void}\n\n\n//@filename {Foo} fileName ./lib/hookContainer.js\n\n//@module blueHTML\n\n'use strict';\n\n//@class HookContainer\nmodule.exports = (function ()\n{\n\t//@method HookContainer\n\t//@constructor\n\t//@return {Void}\n\tfunction HookContainer ()\n\t{\n\t\tthis.hooks = [];\n\t}\n\n\t//@method add Adds a hook into the current hook container\n\t//@param {Hook} hook\n\t//@return {Void}\n\tHookContainer.prototype.add = function (hook)\n\t{\n\t\tthis.hooks.push(hook);\n\t};\n\n\t//@method execute Execute all register hooks\n\t//@param {Any} xx This method allows an arbitrary number of parameters. Only the first only will be accumulated among all hooks and returned\n\t//@return {Any} First parameter passed in\n\tHookContainer.prototype.execute = function ()\n\t{\n\t\tvar args = Array.prototype.slice.call(arguments, 0);\n\n\t\tfor (var i = 0; i < this.hooks.length; i++)\n\t\t{\n\t\t\targs[0] = this.hooks[i].execute.apply(this.hooks[i], args) || args[0];\n\t\t}\n\n\t\treturn args[0];\n\t};\n\n\treturn HookContainer;\n})();\n\n//@class Hook\n//@method execute Execute the plugin itself\n//@param {Any} This method allows a variable numbers of parameters. This will depend on the invocation of the HookContainer\n//@return {Any} The returned value, if any, will be accumulated during the execution of all plugins\n//\n//@property {String} name\n//@property {Number} priority\n\n\n//@filename {Foo} fileName ./index.js\n\n//@module blueHTML\nvar codeGenerator = require('./lib/codeGenerator')\n,\t_ = require('underscore')\n,\tvirtualDOMAdapter = require('./lib/Adapters/virtualDOMAdapter')\n,\treactAdapter = require('./lib/Adapters/reactAdapter')\n,\tcompositeViewPlugin = require('./defaultPlugins/compositionViews');\n\nvar local_parser = new codeGenerator()\n,\tdefaultsAdapters =  {\n\t\t'VD':  virtualDOMAdapter\n\t,\t'R': reactAdapter\n\t};\n\n//@class blueHTML\nmodule.exports = {\n\t//@property {CodeGenerator} codeGenerator\n\tcodeGenerator: codeGenerator\n\n\t//@method generateVirtualDOM Shortcut method to easily start converting handlebarsX to virtual-dom\n\t//@param {String} string_html Handlebar HTML template\n\t//@param {VirtualDOMGenerationOptions} options List of option to configure the parsing process\n\t//@return {String} Final virtual-dom string code already wrapped in a functions\n,\tgenerateVirtualDOM: function (string_html, options)\n\t{\n\t\t'use strict';\n\n\t\toptions = _.defaults(options || {}, {\n\t\t\tnotGenerateContext: false\n\t\t,\tadapterName: 'VD'\n\t\t});\n\n\t\toptions.adapter = options.adapter || defaultsAdapters[options.adapterName];\n\n\t\tvar result = local_parser.generateCode(string_html, options);\n\n\t\treturn result.value;\n\t}\n\t//@property {Object} defaultPlugins Each property of this object is of type Plugin\n,\tdefaultPlugins: {\n\t\t'compositeViews': compositeViewPlugin\n\t}\n\t//@property {Object} defaultsAdapters   Each property of this object is of type Adapter\n,\tdefaultsAdapters: defaultsAdapters\n\t//@method addCustomHandler Method used to define a new custom Handlebars Helper\n\t//@param {ExtenderCodeGeneratorObject} handlebars_custom_handlers\n\t//@return {Void}\n,\taddCustomHandler: local_parser.addCustomHandler\n\t//@method installPlugin Install a plugin inside the code generator\n\t//@param {Plugin} plugin_container\n\t//@return {Void}\n,\tinstallPlugin: local_parser.installPlugin\n};\n\n\n// @class ExtenderCodeGeneratorObject Object used to extend any of the code generators.\n// In this object each property must be a function. Two kind of functions are supported:\n// * \t**Extension Functions**: These are functions that will take the parameters from the Code generator and output a string code.\n//         This can be seen as a point to extend the code generator it self.\n//         This functions are distinguish by the property name they are attached to. In this case the name MUST start with the word 'single' and MUST NOT be 'singleInstance'\n//         Sample:\n//     ```javascript\n//     var blueHTML = require('blueHTML');\n//     blueHTML.addCustomHandler({\n//         'singleTranslate': function (parsing_context, is_inside_context)\n//         {\n//             return 'h(\"div\",[])';\n//         }\n//     });\n//     ```\n//     In this sample, that function will be called each time that in the HTML code appears something like:\n\n//     ```html\n//     <span>{{Translate 'some options'}}</span>\n//     ```\n\n//     Each function MUST fulfill the following signature:\n//     **Function<NodesParsingContext,Boolean,Boolean>** where the output is string and the rest are the input parameter types.\n\n//     For the previous codes, the output will be:\n//     ```javascript\n//     function render(ctx)\n//     {\n//         return h('span', {}, [h('div',[])]);\n//     }\n//     ```\n\n// *   **Helper Functions:** The second options are functions defined in almost the same way you define custom helpers in Handlebars. These functions are distinguish by the property name they are atteched to. In this case the name MUST start with the word 'singleInstance'\n\n//     Sample:\n//     ```javascript\n//     var blueHTML = require('blueHTML');\n//     blueHTML.addCustomHandler({\n//         'singleInstanceTranslate': function (string_key_to_translate)\n//         {\n//             return 'key not found :(';\n//         }\n//     });\n//     ```\n//     In this sample, that function will be called each time that in the HTML code appears something like:\n\n//     ```html\n//     <span>{{Translate 'some options'}}</span>\n//     ```\n\n//     The big difference with previous functions is the signature. While extension function must have a rigid signature that will be called by the code generator, helper functions can have any signature. In the same way you did with Handlebars.\n\n// **Important Note:**\n// 1.   As you can guess, this functions are prefixed with the word *single* as their aim is to handle single helpers. In order word, by the time being **generic block are not supported!!**\n// 2.  The examples here applies to both Attributes and Tags\n\n","classes":{"blueHTML.Adapters.IncrementalDOMAdapter":{"annotation":"class","name":"IncrementalDOMAdapter","text":"","children":[{"annotation":"extend","name":"Adapter","text":"","theRestString":""}],"commentRange":[2,144],"fileName":"./lib/Adapters/incrementalDOMAdapter.js","module":{"annotation":"module","name":"blueHTML.Adapters","text":"","commentRange":[2,144],"fileName":"./lib/Adapters/incrementalDOMAdapter.js"},"absoluteName":"blueHTML.Adapters.IncrementalDOMAdapter","properties":{"Name":{"annotation":"property","type":"{String}","name":"Name","text":"","commentRange":[162,187],"fileName":"./lib/Adapters/incrementalDOMAdapter.js"}},"methods":{"defineAttribute":{"annotation":"method","name":"defineAttribute","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} object_name Name of the object used to accumulate the result of the code generation process @param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes. Besides notice that it can also be a piece of code @return {String}"},{"annotation":"param","type":"{String}","name":"object_name","text":"Name of the object used to accumulate the result of the code generation process","theRestString":"@param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes. Besides notice that it can also be a piece of code @return {String}"},{"annotation":"param","type":"{String}","name":"property_name","text":"Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes. Besides notice that it can also be a piece of code","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[201,653],"fileName":"./lib/Adapters/incrementalDOMAdapter.js"},"setPropertysValue":{"annotation":"method","name":"setPropertysValue","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} property_definition String generated by the invocation of the method defineProperty @param {String} property_accumulated_values Result of the code generation process applied to all the properties value @return {String}"},{"annotation":"param","type":"{String}","name":"property_definition","text":"String generated by the invocation of the method defineProperty","theRestString":"@param {String} property_accumulated_values Result of the code generation process applied to all the properties value @return {String}"},{"annotation":"param","type":"{String}","name":"property_accumulated_values","text":"Result of the code generation process applied to all the properties value","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[810,1139],"fileName":"./lib/Adapters/incrementalDOMAdapter.js"},"accumulatePropertysValue":{"annotation":"method","name":"accumulatePropertysValue","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} object_name Name of the object used to accumulate the result of the code generation process @param {String} property_value Value of the property to set @return {String}"},{"annotation":"param","type":"{String}","name":"object_name","text":"Name of the object used to accumulate the result of the code generation process","theRestString":"@param {String} property_value Value of the property to set @return {String}"},{"annotation":"param","type":"{String}","name":"property_value","text":"Value of the property to set","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[1331,1617],"fileName":"./lib/Adapters/incrementalDOMAdapter.js"}}},"blueHTML.Adapters.ReactAdapter":{"annotation":"class","name":"ReactAdapter","text":"","children":[{"annotation":"extend","name":"Adapter","text":"","theRestString":""}],"commentRange":[1854,1978],"fileName":"./lib/Adapters/reactAdapter.js","module":{"annotation":"module","name":"blueHTML.Adapters","text":"","commentRange":[1854,1978],"fileName":"./lib/Adapters/reactAdapter.js"},"absoluteName":"blueHTML.Adapters.ReactAdapter","properties":{"Name":{"annotation":"property","type":"{String}","name":"Name","text":"","commentRange":[1996,2021],"fileName":"./lib/Adapters/reactAdapter.js"},"emptyTagCollection":{"annotation":"property","type":"{String}","name":"emptyTagCollection","text":"Specify the returned string when a block tag element has none children","commentRange":[2034,2144],"fileName":"./lib/Adapters/reactAdapter.js"}},"methods":{"defineAttribute":{"annotation":"method","name":"defineAttribute","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} object_name Name of the object used to accumulate the result of the code generation process @param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes. Besides notice that it can also be a piece of code @return {String}"},{"annotation":"param","type":"{String}","name":"object_name","text":"Name of the object used to accumulate the result of the code generation process","theRestString":"@param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes. Besides notice that it can also be a piece of code @return {String}"},{"annotation":"param","type":"{String}","name":"property_name","text":"Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes. Besides notice that it can also be a piece of code","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[2173,2625],"fileName":"./lib/Adapters/reactAdapter.js"},"accumulateFinalAttributesResult":{"annotation":"method","name":"accumulateFinalAttributesResult","text":"Wrap up the final result after all attributes were converted to code","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"attributes_result","text":"","theRestString":"@param {String} code_generation_context @return {String}"},{"annotation":"param","type":"{String}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[2989,3214],"fileName":"./lib/Adapters/reactAdapter.js"},"setPropertysValue":{"annotation":"method","name":"setPropertysValue","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} property_definition String generated by the invocation of the method defineProperty @param {String} property_accumulated_values Result of the code generation process applied to all the properties value @return {String}"},{"annotation":"param","type":"{String}","name":"property_definition","text":"String generated by the invocation of the method defineProperty","theRestString":"@param {String} property_accumulated_values Result of the code generation process applied to all the properties value @return {String}"},{"annotation":"param","type":"{String}","name":"property_accumulated_values","text":"Result of the code generation process applied to all the properties value","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[3529,3858],"fileName":"./lib/Adapters/reactAdapter.js"},"accumulatePropertysValue":{"annotation":"method","name":"accumulatePropertysValue","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} object_name Name of the object used to accumulate the result of the code generation process @param {String} property_value Value of the property to set @return {String}"},{"annotation":"param","type":"{String}","name":"object_name","text":"Name of the object used to accumulate the result of the code generation process","theRestString":"@param {String} property_value Value of the property to set @return {String}"},{"annotation":"param","type":"{String}","name":"property_value","text":"Value of the property to set","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[4050,4336],"fileName":"./lib/Adapters/reactAdapter.js"},"defineBlockTag":{"annotation":"method","name":"defineBlockTag","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} attributes_result Result of generating the code to all of the tag attributes @param {String} children_result Accumulated result for all tag's children @return {String}"},{"annotation":"param","type":"{String}","name":"attributes_result","text":"Result of generating the code to all of the tag attributes","theRestString":"@param {String} children_result Accumulated result for all tag's children @return {String}"},{"annotation":"param","type":"{String}","name":"children_result","text":"Accumulated result for all tag's children","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[4543,4818],"fileName":"./lib/Adapters/reactAdapter.js"},"defineSingleTag":{"annotation":"method","name":"defineSingleTag","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} attributes_result Result of generating the code to all of the tag attributes @return {String}"},{"annotation":"param","type":"{String}","name":"attributes_result","text":"Result of generating the code to all of the tag attributes","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[5100,5299],"fileName":"./lib/Adapters/reactAdapter.js"},"defineTextTag":{"annotation":"method","name":"defineTextTag","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} text Take into account that this variable can contain code to be evaluated! @return {String}"},{"annotation":"param","type":"{String}","name":"text","text":"Take into account that this variable can contain code to be evaluated!","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[5488,5684],"fileName":"./lib/Adapters/reactAdapter.js"},"accumulateFinalTagsResult":{"annotation":"method","name":"accumulateFinalTagsResult","text":"Wrap up the final result get after all tags were converted to code. Please notice that at this point the string code passed in generation_result parameter contains the entire resulting code","children":[{"annotation":"param","type":"{CodeGenerationOptions}","name":"options","text":"","theRestString":"@param {CodeGenerationResult} geneation_result @return {geneation_result}"},{"annotation":"param","type":"{CodeGenerationResult}","name":"geneation_result","text":"","theRestString":"@return {geneation_result}"},{"annotation":"return","type":"{geneation_result}","text":"","theRestString":""}],"commentRange":[5782,6132],"fileName":"./lib/Adapters/reactAdapter.js"},"_removeBrackets":{"annotation":"method","name":"_removeBrackets","text":"Auxiliary method to remove bracket generated by the fist call to the Tags iteration method (iterateOverTagNodes)","children":[{"annotation":"param","type":"{String}","name":"code","text":"Code to clean","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[6721,6917],"fileName":"./lib/Adapters/reactAdapter.js"}}},"blueHTML.Adapters.Adapter":{"annotation":"class","name":"Adapter","text":"","commentRange":[7393,7501],"fileName":"./lib/Adapters/virtualDOMAdapter.js","module":{"annotation":"module","name":"blueHTML.Adapters","text":"","commentRange":[7393,7501],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"absoluteName":"blueHTML.Adapters.Adapter","properties":{"Name":{"annotation":"property","type":"{String}","name":"Name","text":"Stringn that identify each adapter","commentRange":[7519,7579],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"emptyTagCollection":{"annotation":"property","type":"{String}","name":"emptyTagCollection","text":"Specify the returned string when a block tag element has none children","commentRange":[7593,7703],"fileName":"./lib/Adapters/virtualDOMAdapter.js"}},"methods":{"defineAttribute":{"annotation":"method","name":"defineAttribute","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} object_name Name of the object used to accumulate the result of the code generation process @param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes. Besides notice that it can also be a piece of code @return {String}"},{"annotation":"param","type":"{String}","name":"object_name","text":"Name of the object used to accumulate the result of the code generation process","theRestString":"@param {String} property_name Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes. Besides notice that it can also be a piece of code @return {String}"},{"annotation":"param","type":"{String}","name":"property_name","text":"Name of the property to define. Please notice that this value will come formatted. This means that if it is a string it will already have its quotes. Besides notice that it can also be a piece of code","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[7732,8184],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"accumulateFinalAttributesResult":{"annotation":"method","name":"accumulateFinalAttributesResult","text":"Wrap up the final result get after all attributes were converted to code","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} attributes_result @return {String}"},{"annotation":"param","type":"{String}","name":"attributes_result","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[8341,8570],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"setPropertysValue":{"annotation":"method","name":"setPropertysValue","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} property_definition String generated by the invocation of the method defineProperty @param {String} property_accumulated_values Result of the code generation process applied to all the properties value @return {String}"},{"annotation":"param","type":"{String}","name":"property_definition","text":"String generated by the invocation of the method defineProperty","theRestString":"@param {String} property_accumulated_values Result of the code generation process applied to all the properties value @return {String}"},{"annotation":"param","type":"{String}","name":"property_accumulated_values","text":"Result of the code generation process applied to all the properties value","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[8897,9226],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"accumulatePropertysValue":{"annotation":"method","name":"accumulatePropertysValue","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} object_name Name of the object used to accumulate the result of the code generation process @param {String} property_value Value of the property to set @return {String}"},{"annotation":"param","type":"{String}","name":"object_name","text":"Name of the object used to accumulate the result of the code generation process","theRestString":"@param {String} property_value Value of the property to set @return {String}"},{"annotation":"param","type":"{String}","name":"property_value","text":"Value of the property to set","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[9418,9704],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"defineBlockTag":{"annotation":"method","name":"defineBlockTag","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} attributes_result Result of generating the code to all of the tag attributes @param {String} children_result Accumulated result for all tag's children @return {String}"},{"annotation":"param","type":"{String}","name":"attributes_result","text":"Result of generating the code to all of the tag attributes","theRestString":"@param {String} children_result Accumulated result for all tag's children @return {String}"},{"annotation":"param","type":"{String}","name":"children_result","text":"Accumulated result for all tag's children","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[9911,10186],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"defineSingleTag":{"annotation":"method","name":"defineSingleTag","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} attributes_result Result of generating the code to all of the tag attributes @return {String}"},{"annotation":"param","type":"{String}","name":"attributes_result","text":"Result of generating the code to all of the tag attributes","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[10392,10591],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"defineTextTag":{"annotation":"method","name":"defineTextTag","text":"","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {String} text Take into account that this variable can contain code to be evaluated! @return {String}"},{"annotation":"param","type":"{String}","name":"text","text":"Take into account that this variable can contain code to be evaluated!","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[10760,10956],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"accumulateFinalTagsResult":{"annotation":"method","name":"accumulateFinalTagsResult","text":"Wrap up the final result get after all tags were converted to code. Please notice that at this point the string code passed in generation_result parameter contains the entire resulting code","children":[{"annotation":"param","type":"{CodeGenerationOptions}","name":"options","text":"","theRestString":"@param {CodeGenerationResult} geneation_result @return {geneation_result}"},{"annotation":"param","type":"{CodeGenerationResult}","name":"geneation_result","text":"","theRestString":"@return {geneation_result}"},{"annotation":"return","type":"{geneation_result}","text":"","theRestString":""}],"commentRange":[11054,11404],"fileName":"./lib/Adapters/virtualDOMAdapter.js"}}},"blueHTML.Adapters.VirtualDOMAdapter":{"annotation":"class","name":"VirtualDOMAdapter","text":"","children":[{"annotation":"extend","name":"Adapter","text":"","theRestString":""}],"commentRange":[11820,11862],"fileName":"./lib/Adapters/virtualDOMAdapter.js","module":{"annotation":"module","name":"blueHTML.Adapters","text":"","commentRange":[7393,7501],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"absoluteName":"blueHTML.Adapters.VirtualDOMAdapter"},"blueHTML.CodeGenerator":{"annotation":"class","name":"CodeGenerator","text":"\n\nClass responsible to call the Handlebars parsers and from that result generate Virtual-DOM code\n\n\n\n\n\n\n\n\n\n\n\n","commentRange":[12057,12079],"fileName":"./lib/codeGenerator.Attributes.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[11890,11970],"fileName":"./lib/codeGenerator.Attributes.js"},"absoluteName":"blueHTML.CodeGenerator","methods":{"concatenateAttributeNodes":{"annotation":"method","name":"concatenateAttributeNodes","text":"Given a list of ast nodes, generate the concatenated string that represent the result of applying all the action specified in all the nodes","children":[{"annotation":"param","type":"{Array<AttributeASTNode>}","name":"nodes","text":"List of node to concatenate","theRestString":"@param {CodeGenerationContext} code_generation_context @return {String}"},{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[12102,12425],"fileName":"./lib/codeGenerator.Attributes.js"},"parseAttributes":{"annotation":"method","name":"parseAttributes","text":"Internal method call when any attributes string need to be parsed. This method delegate the parsing task to the Attributes Parser Manager","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[13456,13697],"fileName":"./lib/codeGenerator.Attributes.js"},"keyValue":{"annotation":"method","name":"keyValue","text":"Handle the parsing of all node of type keyValue","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[15632,16072],"fileName":"./lib/codeGenerator.Attributes.js"},"singleValue":{"annotation":"method","name":"singleValue","text":"Handle the parsing of all node of type singleKey (Generally one single word used to set a property name)","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[17702,17906],"fileName":"./lib/codeGenerator.Attributes.js"},"handlebarsATTRSINGLEEVALUATION":{"annotation":"method","name":"handlebarsATTRSINGLEEVALUATION","text":"Handle the parsing of all safe evaluation handlebars node","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[18952,19430],"fileName":"./lib/codeGenerator.Attributes.js"},"handlebarsATTRLOOKUPSINGLE":{"annotation":"method","name":"handlebarsATTRLOOKUPSINGLE","text":"Handle the parsing of all context lookup","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[20157,20312],"fileName":"./lib/codeGenerator.Attributes.js"},"handlebarsATTRUNSAFESINGLEEVALUATION":{"annotation":"method","name":"handlebarsATTRUNSAFESINGLEEVALUATION","text":"Handle the parsing of all un-safe evaluation handlebars node","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[21025,21210],"fileName":"./lib/codeGenerator.Attributes.js"},"handlebarsATTRREFERENCEEVALUATION":{"annotation":"method","name":"handlebarsATTRREFERENCEEVALUATION","text":"Handle the parsing of safe reference evaluation handlebar nodes","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[21923,22108],"fileName":"./lib/codeGenerator.Attributes.js"},"handlebarsATTRIF":{"annotation":"method","name":"handlebarsATTRIF","text":"Handle the parsing of all IF handlebars node","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[23296,23445],"fileName":"./lib/codeGenerator.Attributes.js"},"handlebarsATTREACH":{"annotation":"method","name":"handlebarsATTREACH","text":"Handle the parsing of all EACHs handlebars node","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[24217,24371],"fileName":"./lib/codeGenerator.Attributes.js"},"handlebarsATTRUNLESS":{"annotation":"method","name":"handlebarsATTRUNLESS","text":"Handle the parsing of all UNLESS handlebars node","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[26047,26204],"fileName":"./lib/codeGenerator.Attributes.js"},"getNodeHandle":{"annotation":"method","name":"getNodeHandle","text":"Auxiliary method that given a node, returns the method (of this class) that will handle/parse it Please notice that the searched function must fulfill the criteria based on the name of the type of the ast node","children":[{"annotation":"param","type":"{NodeASTNode}","name":"ast_node","text":"Node used to look a handle for","theRestString":"@return {Function<CodeGenerationContext, Boolean, String>}"},{"annotation":"return","type":"{Function<CodeGenerationContext, Boolean, String>}","text":"","theRestString":""}],"commentRange":[31513,31876],"fileName":"./lib/codeGenerator.Base.js"},"_joinExternalFunctionParameters":{"annotation":"method","name":"_joinExternalFunctionParameters","text":"Internal method to join parameters used by external functions","children":[{"annotation":"param","type":"{Array<ParameterNode>}","name":"parameters","text":"","theRestString":"@param {CodeGenerationContext} code_generation_context @return {String}"},{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[37928,38153],"fileName":"./lib/codeGenerator.CustomHelpers.js"},"runtimeGenericSingleHandle":{"annotation":"method","name":"runtimeGenericSingleHandle","text":"This method converts all passed in function that represent extra helpers to string in a safe way","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {Function<CodeGenerationContext, Boolean, String>}"},{"annotation":"return","type":"{Function<CodeGenerationContext, Boolean, String>}","text":"","theRestString":""}],"commentRange":[38985,39238],"fileName":"./lib/codeGenerator.CustomHelpers.js"},"runtimeGenericBlockHandle":{"annotation":"method","name":"runtimeGenericBlockHandle","text":"This method converts all passed in function that represent extra helpers to string in a safe way","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {Function<CodeGenerationContext, Boolean, String>}"},{"annotation":"return","type":"{Function<CodeGenerationContext, Boolean, String>}","text":"","theRestString":""}],"commentRange":[40093,40345],"fileName":"./lib/codeGenerator.CustomHelpers.js"},"iterateOverTagNodes":{"annotation":"method","name":"iterateOverTagNodes","text":"Given a list of ast nodes, iterate over them and returns a string that represent its union.","children":[{"annotation":"param","type":"{Array<NodeASTNode>}","name":"nodes","text":"List of nodes to iterate","theRestString":"@param {CodeGenerationContext} code_generation_context Current code generation context @param {Boolean} parent_require_new_context Indicate if the parent, the function that calls this function, requires that the result be in another execution context or not. @return {String} Portion of code that group all the nodes passed in"},{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"Current code generation context","theRestString":"@param {Boolean} parent_require_new_context Indicate if the parent, the function that calls this function, requires that the result be in another execution context or not. @return {String} Portion of code that group all the nodes passed in"},{"annotation":"param","type":"{Boolean}","name":"parent_require_new_context","text":"Indicate if the parent, the function that calls this function, requires that the result be in another execution context or not.","theRestString":"@return {String} Portion of code that group all the nodes passed in"},{"annotation":"return","type":"{String}","name":"Portion","text":"of code that group all the nodes passed in","theRestString":""}],"commentRange":[41081,41604],"fileName":"./lib/codeGenerator.Tags.js"},"htmlBlockNode":{"annotation":"method","name":"htmlBlockNode","text":"Handle standard HTML blocks","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[43004,43430],"fileName":"./lib/codeGenerator.Tags.js"},"htmlSingleNode":{"annotation":"method","name":"htmlSingleNode","text":"Handle standard one liner HTML","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[44183,44316],"fileName":"./lib/codeGenerator.Tags.js"},"text":{"annotation":"method","name":"text","text":"Handle plain text inside the HTML document","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[44930,45065],"fileName":"./lib/codeGenerator.Tags.js"},"htmlComment":{"annotation":"method","name":"htmlComment","text":"Handle standard HTML comments","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[45527,45656],"fileName":"./lib/codeGenerator.Tags.js"},"_concatenateValues":{"annotation":"method","name":"_concatenateValues","text":"Concatenate/Composite a bunch of results into the accumulator variable. Used when the conversion is done inside a new context.","children":[{"annotation":"param","type":"{String}","name":"accumulator_variable_name","text":"Name of the variable than has all the results","theRestString":"@param {String} children_result Result to be appended @param {CodeGenerationContext} code_generation_context @param {Boolean} are_children_array Indicate if the children_result param is an array or not. (If false children_result will be wrapper with '[' ']' characters) @return {String}"},{"annotation":"param","type":"{String}","name":"children_result","text":"Result to be appended","theRestString":"@param {CodeGenerationContext} code_generation_context @param {Boolean} are_children_array Indicate if the children_result param is an array or not. (If false children_result will be wrapper with '[' ']' characters) @return {String}"},{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {Boolean} are_children_array Indicate if the children_result param is an array or not. (If false children_result will be wrapper with '[' ']' characters) @return {String}"},{"annotation":"param","type":"{Boolean}","name":"are_children_array","text":"Indicate if the children_result param is an array or not. (If false children_result will be wrapper with '[' ']' characters)","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[45804,46651],"fileName":"./lib/codeGenerator.Tags.js"},"handlebarsSINGLECOMMENTS":{"annotation":"method","name":"handlebarsSINGLECOMMENTS","text":"Handle the parsing of handlebar line comments","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[47217,47677],"fileName":"./lib/codeGenerator.Tags.js"},"handlebarsSAFEEVALUATION":{"annotation":"method","name":"handlebarsSAFEEVALUATION","text":"Handle the parsing of safe evaluation handlebar nodes","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[47833,47999],"fileName":"./lib/codeGenerator.Tags.js"},"handlebarsUNSAFEEVALUATION":{"annotation":"method","name":"handlebarsUNSAFEEVALUATION","text":"Handle the parsing of unsafe evaluation handlebar nodes","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[48521,48691],"fileName":"./lib/codeGenerator.Tags.js"},"handlebarsLOOKUPSINGLE":{"annotation":"method","name":"handlebarsLOOKUPSINGLE","text":"Handle the parsing of single lookup variable evaluation","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[49206,49372],"fileName":"./lib/codeGenerator.Tags.js"},"handlebarsSAFEREFERENCEEVALUATION":{"annotation":"method","name":"handlebarsSAFEREFERENCEEVALUATION","text":"Handle the parsing of safe reference evaluation handlebar nodes","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[49912,50097],"fileName":"./lib/codeGenerator.Tags.js"},"handlebarsEACH":{"annotation":"method","name":"handlebarsEACH","text":"Handle the parsing of each handlebar nodes","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[50941,51086],"fileName":"./lib/codeGenerator.Tags.js"},"handlebarsIF":{"annotation":"method","name":"handlebarsIF","text":"Handle the parsing of IF handlebar nodes Notice that the second param 'not_consider_context' is indeed being passed in to this function, it is just the it does not make sense to used, as we always need to run any handlebars conversion in the context of a function, '(function () {}()'","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[54102,54495],"fileName":"./lib/codeGenerator.Tags.js"},"handlebarsUNLESS":{"annotation":"method","name":"handlebarsUNLESS","text":"Handle the parsing of UNLESS handlebar nodes","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[55208,55357],"fileName":"./lib/codeGenerator.Tags.js"},"_generateUniqueId":{"annotation":"method","name":"_generateUniqueId","text":"Internal method used to create unique identifiers. Copy of underscore.uniqueId. It is copy here in order to control it's internal state.","children":[{"annotation":"param","text":"{String?} prefix Optional prefix","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[56294,56525],"fileName":"./lib/codeGenerator.Utils.js //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// UTILS // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////"},"_serializeContext":{"annotation":"method","name":"_serializeContext","text":"Internal method used to serialize a context object. This method is used by each handlebar block object that defines a new context. For example EACH Notice that the presence of any property called contextName will NOT be included in the final result","children":[{"annotation":"param","type":"{Object}","name":"context","text":"Any plain javascript object with one 'value' property","theRestString":"@param {String} variable_name Name of the object in the returned string @param {String} value_name Name of the value property in the returned string @return {String}"},{"annotation":"param","type":"{String}","name":"variable_name","text":"Name of the object in the returned string","theRestString":"@param {String} value_name Name of the value property in the returned string @return {String}"},{"annotation":"param","type":"{String}","name":"value_name","text":"Name of the value property in the returned string","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[56669,57205],"fileName":"./lib/codeGenerator.Utils.js //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// UTILS // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////"},"_getLookUpContextName":{"annotation":"method","name":"_getLookUpContextName","text":"Internal method to find the context name in the case of look Ups","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {NodeASTNode} node @return {String}"},{"annotation":"param","type":"{NodeASTNode}","name":"node","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[57688,57891],"fileName":"./lib/codeGenerator.Utils.js //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// UTILS // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////"},"_handlebarsEvaluateCondition":{"annotation":"method","name":"_handlebarsEvaluateCondition","text":"Evaluates the condition of IFs, UNLESSs and EACHs. As these values can be single evaluation or lookups","children":[{"annotation":"param","type":"{CodeGenerationContext}","name":"code_generation_context","text":"","theRestString":"@param {ConditionNode} condition @return {String}"},{"annotation":"param","type":"{ConditionNode}","name":"condition","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[58751,59006],"fileName":"./lib/codeGenerator.Utils.js //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// UTILS // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////"},"addCustomHandler":{"annotation":"method","name":"addCustomHandler","text":"Add a new handlebars handler","children":[{"annotation":"param","type":"{Function }","text":"@return {Void}","theRestString":""}],"commentRange":[60505,60604],"fileName":"./lib/codeGenerator.js"},"installPlugin":{"annotation":"method","name":"installPlugin","text":"Install a plugin inside the code generator","children":[{"annotation":"param","type":"{Plugin}","name":"plugin_container","text":"","theRestString":"@return {Void}"},{"annotation":"return","type":"{Void}","text":"","theRestString":""}],"commentRange":[60746,60870],"fileName":"./lib/codeGenerator.js"}},"children":[],"properties":{"beforeAttributeHandlerRetrieved":{"annotation":"property","type":"{HookContainer}","name":"beforeAttributeHandlerRetrieved","text":"Static plugin property invoked before the attributes handlebars handler is detected/retrieved. Aim: Edit the selected attribute AST Node before being used to detect the handler Its invocation has the following signature: Function<AttributeASTNode, CodeGenerationContext, AttributeASTNode> where the last value is the optional return one.","commentRange":[32777,33486],"fileName":"./lib/codeGenerator.Base.js"},"beforeAttributeHandlerExecuted":{"annotation":"property","type":"{HookContainer}","name":"beforeAttributeHandlerExecuted","text":"Static plugin property invoked before the attributes handlebars handler is executed Aim: Edit the selected attribute AST node before being used by the selected handle and wrap the selected handler function Its invocation has the following signature: Function<AttributeASTNode, CodeGenerationContext, Object<handler:function>, AttributeASTNode> where the last value is the optional return one.","commentRange":[33559,34016],"fileName":"./lib/codeGenerator.Base.js"},"afterAttributeHandlerExecuted":{"annotation":"property","type":"{HookContainer}","name":"afterAttributeHandlerExecuted","text":"Static plugin property invoked after the attributes handlebars handler is executed Aim: Access the accumulated attribute generated code up to the moment, access the result of the function handler and add another step to edit the selected attribute AST node Its invocation has the following signature: Function<AttributeASTNode, CodeGenerationContext, Object<acummulatedValue:String, currentResult:String>, AttributeASTNode> where the last value is the optional return one.","commentRange":[34087,34623],"fileName":"./lib/codeGenerator.Base.js"},"beforeAttributeCodeGeneration":{"annotation":"property","type":"{HookContainer}","name":"beforeAttributeCodeGeneration","text":"Static plugin property invoked when at the beginning of the attributes code generation process for each tag node. Aim: Access the entire Tag node that contains the attributes sub-tree, and to initialize plugin's state related with the attributes code generation Its invocation has the following signature: Function<AttributeASTNode, CodeGenerationContext, AttributeASTNode> where the last value is the optional return one.","commentRange":[34694,35180],"fileName":"./lib/codeGenerator.Base.js"},"afterAttributeCodeGeneration":{"annotation":"property","type":"{HookContainer}","name":"afterAttributeCodeGeneration","text":"Static plugin property invoked when at the end of the attributes code generation process for each tag node. Aim: Access/Edit the entire result of attributes code generation, also to clean up any plugin's state Its invocation has the following signature: Function<String, CodeGenerationContext, String> where the last value is the optional return one.","commentRange":[35250,35663],"fileName":"./lib/codeGenerator.Base.js"},"beforeTagCodeGeneration":{"annotation":"property","type":"{HookContainer}","name":"beforeTagCodeGeneration","text":"Static plugin property invoked at the beginning of the entire code generation process Aim: Access/Edit the entire string template and initalize any plugin state Its invocation has the following signature: Function<String, CodeGenerationContext, String> where the last value is the optional return one.","commentRange":[35733,36092],"fileName":"./lib/codeGenerator.Base.js"},"afterTagCodeGeneration":{"annotation":"property","type":"{HookContainer}","name":"afterTagCodeGeneration","text":"Static plugin property invoked at the end of the entire code generation process Aim: Access/Edit the entire code generation process result Its invocation has the following signature: Function<CodeGenerationResult, CodeGenerationContext, CodeGenerationResult> where the last value is the optional return one.","commentRange":[36156,36520],"fileName":"./lib/codeGenerator.Base.js"},"afterTagEachContextCreation":{"annotation":"property","type":"{HookContainer}","name":"afterTagEachContextCreation","text":"Static plugin property invoked before handlebars 'EACH' tags context is created Aim: Augment the EACH context Its invocation has the following signature: Function<HandlebarsEACHContext, CodeGenerationContext, HandlebarsEACHContext> where the last value is the optional return one.","commentRange":[37031,37373],"fileName":"./lib/codeGenerator.Base.js"}}},"blueHTML.CodeGenerationContext":{"annotation":"class","name":"CodeGenerationContext","text":"\n\nThis class holds all the information and data used during the code generation process","commentRange":[13925,14094],"fileName":"./lib/codeGenerator.Attributes.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[11890,11970],"fileName":"./lib/codeGenerator.Attributes.js"},"absoluteName":"blueHTML.CodeGenerationContext","properties":{"isSettingValue":{"annotation":"property","type":"{Boolean}","name":"isSettingValue","text":"Indicate if in the current context the value of a property is being set or just the property itself","commentRange":[13925,14094],"fileName":"./lib/codeGenerator.Attributes.js"},"objectName":{"annotation":"property","type":"{String}","name":"objectName","text":"Name of the object where all the properties are added. Property used in the context of the Attributes code generation.","commentRange":[14147,14297],"fileName":"./lib/codeGenerator.Attributes.js"},"keyName":{"annotation":"property","type":"{String}","name":"keyName","text":"Property used in the context of the Attributes code generation to indicate the name of the property being generated","commentRange":[14373,14517],"fileName":"./lib/codeGenerator.Attributes.js"},"isSettingAttributes.":{"annotation":"property","type":"{Boolean}","name":"isSettingAttributes.","text":"Property used in the context of the Attributes code generation. Falsy otherwise","commentRange":[14560,14682],"fileName":"./lib/codeGenerator.Attributes.js"},"astNode":{"annotation":"property","type":"{NodeASTNode}","name":"astNode","text":"Current node being processed","commentRange":[29869,29931],"fileName":"./lib/codeGenerator.Base.js"},"contextStack":{"annotation":"property","type":"{Array<ContextContainer>}","name":"contextStack","text":"Stack where all context names are saved. Used in functions like handlebars EACH that change the current context name.","commentRange":[30055,30223],"fileName":"./lib/codeGenerator.Base.js"},"variableName":{"annotation":"property","type":"{String}","name":"variableName","text":"Name of the variable that accumulate all virtual-dom elements","commentRange":[30250,30345],"fileName":"./lib/codeGenerator.Base.js"},"externalDependenciesObjectName":{"annotation":"property","type":"{String}","name":"externalDependenciesObjectName","text":"Name of the object that will carry all external dependencies","commentRange":[30645,30757],"fileName":"./lib/codeGenerator.Base.js"},"adapter":{"annotation":"property","type":"{Adapter}","name":"adapter","text":"","commentRange":[30843,30872],"fileName":"./lib/codeGenerator.Base.js"}},"children":[]},"blueHTML.CodeGenerationOptions":{"annotation":"class","name":"CodeGenerationOptions","text":"","commentRange":[27224,27254],"fileName":"./lib/codeGenerator.Base.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[26858,26932],"fileName":"./lib/codeGenerator.Base.js"},"absoluteName":"blueHTML.CodeGenerationOptions","properties":{"contextName":{"annotation":"property","type":"{ContextContainer}","name":"contextName","text":"Name of the initial context when running the returned string code. Default value: 'ctx'","commentRange":[27291,27421],"fileName":"./lib/codeGenerator.Base.js"},"variableName":{"annotation":"property","type":"{String}","name":"variableName","text":"Name of the variable used to accumulate all virtual dom nodes.","commentRange":[27465,27561],"fileName":"./lib/codeGenerator.Base.js"},"allowMultiplesFathers":{"annotation":"property","type":"{Boolean}","name":"allowMultiplesFathers","text":"","commentRange":[27594,27637],"fileName":"./lib/codeGenerator.Base.js"},"attributeObjectName":{"annotation":"property","type":"{Sring}","name":"attributeObjectName","text":"","commentRange":[27674,27713],"fileName":"./lib/codeGenerator.Base.js"},"externalDependenciesObjectName":{"annotation":"property","type":"{Sring}","name":"externalDependenciesObjectName","text":"","commentRange":[27748,27798],"fileName":"./lib/codeGenerator.Base.js"}},"methods":{"codeGenerator":{"annotation":"method","name":"codeGenerator","text":"","commentRange":[27866,27923],"fileName":"./lib/codeGenerator.Base.js"},"generateCode":{"annotation":"method","name":"generateCode","text":"Public method to generate code","children":[{"annotation":"param","type":"{String}","name":"string_hx","text":"HTML/HandlebarX code to parse","theRestString":"@param {CodeGenerationOptions} options @return {CodeGenerationResult}"},{"annotation":"param","type":"{CodeGenerationOptions}","name":"options","text":"","theRestString":"@return {CodeGenerationResult}"},{"annotation":"return","type":"{CodeGenerationResult}","text":"","theRestString":""}],"commentRange":[28019,28207],"fileName":"./lib/codeGenerator.Base.js"},"_parse":{"annotation":"method","name":"_parse","text":"Internal method that parse the given string and generates the corresponding a virtual-dom string","children":[{"annotation":"param","type":"{String}","name":"string","text":"HTML/Handlebar code to parse","theRestString":"@return {CodeGenerationResult}"},{"annotation":"return","type":"{CodeGenerationResult}","text":"","theRestString":""}],"commentRange":[28868,29070],"fileName":"./lib/codeGenerator.Base.js"}},"constructors":[{"annotation":"constructor","name":"n","text":"","children":[{"annotation":"return","type":"{Void}","text":"","theRestString":""}],"commentRange":[27866,27923],"fileName":"./lib/codeGenerator.Base.js","params":[],"throws":[]}]},"blueHTML.CodeGenerationResult":{"annotation":"class","name":"CodeGenerationResult","text":"","commentRange":[29144,29173],"fileName":"./lib/codeGenerator.Base.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[26858,26932],"fileName":"./lib/codeGenerator.Base.js"},"absoluteName":"blueHTML.CodeGenerationResult","properties":{"contextName":{"annotation":"property","type":"{String}","name":"contextName","text":"","commentRange":[29207,29239],"fileName":"./lib/codeGenerator.Base.js"},"value":{"annotation":"property","type":"{String}","name":"value","text":"Final string result","commentRange":[29292,29338],"fileName":"./lib/codeGenerator.Base.js"},"externalDependencies":{"annotation":"property","type":"{Arra<String>}","name":"externalDependencies","text":"General purpose array to be used by plugins to add any external dependency","commentRange":[29358,29480],"fileName":"./lib/codeGenerator.Base.js"},"externalDependenciesObjectName":{"annotation":"property","type":"{String}","name":"externalDependenciesObjectName","text":"Name of the object that will carry all external dependencies","commentRange":[29515,29627],"fileName":"./lib/codeGenerator.Base.js"}}},"blueHTML.HandlebarsEACHContext":{"annotation":"class","name":"HandlebarsEACHContext","text":"","commentRange":[51732,51762],"fileName":"./lib/codeGenerator.Tags.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[40876,40950],"fileName":"./lib/codeGenerator.Tags.js"},"absoluteName":"blueHTML.HandlebarsEACHContext","properties":{"value":{"annotation":"property","type":"{String}","name":"value","text":"","commentRange":[51788,51814],"fileName":"./lib/codeGenerator.Tags.js"},"first":{"annotation":"property","type":"{String}","name":"first","text":"This string, when compiled will be converted to Boolean","commentRange":[51853,51935],"fileName":"./lib/codeGenerator.Tags.js"},"last":{"annotation":"property","type":"{String}","name":"last","text":"This string, when compiled will be converted to Boolean","commentRange":[51979,52060],"fileName":"./lib/codeGenerator.Tags.js"},"index":{"annotation":"property","type":"{String}","name":"index","text":"This string, when compiled will be converted to Number","commentRange":[52131,52212],"fileName":"./lib/codeGenerator.Tags.js"},"contextName":{"annotation":"property","type":"{String}","name":"contextName","text":"","commentRange":[52244,52276],"fileName":"./lib/codeGenerator.Tags.js"}}},"blueHTML.Plugin":{"annotation":"class","name":"Plugin","text":"","commentRange":[61110,61331],"fileName":"./lib/codeGenerator.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[60043,60112],"fileName":"./lib/codeGenerator.js"},"absoluteName":"blueHTML.Plugin","methods":{"install":{"annotation":"method","name":"install","text":"Public method invoked by blueHTML when adding a new plugin.","children":[{"annotation":"param","type":"{CodeGenerator}","name":"codeGenerator","text":"","theRestString":"@return {Void}"},{"annotation":"return","type":"{Void}","text":"","theRestString":""}],"commentRange":[61110,61331],"fileName":"./lib/codeGenerator.js"}}},"blueHTML.HookContainer":{"annotation":"class","name":"HookContainer","text":"","commentRange":[61348,61370],"fileName":"./lib/hookContainer.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[61110,61331],"fileName":"./lib/hookContainer.js"},"absoluteName":"blueHTML.HookContainer","methods":{"HookContainer":{"annotation":"method","name":"HookContainer","text":"","commentRange":[61404,61461],"fileName":"./lib/hookContainer.js"},"add":{"annotation":"method","name":"add","text":"Adds a hook into the current hook container","children":[{"annotation":"param","type":"{Hook}","name":"hook","text":"","theRestString":"@return {Void}"},{"annotation":"return","type":"{Void}","text":"","theRestString":""}],"commentRange":[61516,61613],"fileName":"./lib/hookContainer.js"},"execute":{"annotation":"method","name":"execute","text":"Execute all register hooks","children":[{"annotation":"param","type":"{Any}","name":"xx","text":"This method allows an arbitrary number of parameters. Only the first only will be accumulated among all hooks and returned","theRestString":"@return {Any} First parameter passed in"},{"annotation":"return","type":"{Any}","name":"First","text":"parameter passed in","theRestString":""}],"commentRange":[61695,61924],"fileName":"./lib/hookContainer.js"}},"constructors":[{"annotation":"constructor","name":"n","text":"","children":[{"annotation":"return","type":"{Void}","text":"","theRestString":""}],"commentRange":[61404,61461],"fileName":"./lib/hookContainer.js","params":[],"throws":[]}]},"blueHTML.Hook":{"annotation":"class","name":"Hook","text":"","commentRange":[62213,62613],"fileName":"./lib/hookContainer.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[61110,61331],"fileName":"./lib/hookContainer.js"},"absoluteName":"blueHTML.Hook","methods":{"execute":{"annotation":"method","name":"execute","text":"Execute the plugin itself","children":[{"annotation":"param","type":"{Any}","name":"This","text":"method allows a variable numbers of parameters. This will depend on the invocation of the HookContainer","theRestString":"@return {Any} The returned value, if any, will be accumulated during the execution of all plugins"},{"annotation":"return","type":"{Any}","name":"The","text":"returned value, if any, will be accumulated during the execution of all plugins","theRestString":""}],"commentRange":[62213,62613],"fileName":"./lib/hookContainer.js"}},"properties":{"name":{"annotation":"property","type":"{String}","name":"name","text":"","commentRange":[62213,62613],"fileName":"./lib/hookContainer.js"},"priority":{"annotation":"property","type":"{Number}","name":"priority","text":"","commentRange":[62213,62613],"fileName":"./lib/hookContainer.js"}}},"blueHTML.blueHTML":{"annotation":"class","name":"blueHTML","text":"","commentRange":[63002,63019],"fileName":"./index.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[62213,62613],"fileName":"./index.js"},"absoluteName":"blueHTML.blueHTML","properties":{"codeGenerator":{"annotation":"property","type":"{CodeGenerator}","name":"codeGenerator","text":"","commentRange":[63040,63081],"fileName":"./index.js"},"defaultPlugins":{"annotation":"property","type":"{Object}","name":"defaultPlugins","text":"Each property of this object is of type Plugin","commentRange":[63788,63870],"fileName":"./index.js"},"defaultsAdapters":{"annotation":"property","type":"{Object}","name":"defaultsAdapters","text":"Each property of this object is of type Adapter","commentRange":[63935,64022],"fileName":"./index.js"}},"methods":{"generateVirtualDOM":{"annotation":"method","name":"generateVirtualDOM","text":"Shortcut method to easily start converting handlebarsX to virtual-dom","children":[{"annotation":"param","type":"{String}","name":"string_html","text":"Handlebar HTML template","theRestString":"@param {VirtualDOMGenerationOptions} options List of option to configure the parsing process @return {String} Final virtual-dom string code already wrapped in a functions"},{"annotation":"param","type":"{VirtualDOMGenerationOptions}","name":"options","text":"List of option to configure the parsing process","theRestString":"@return {String} Final virtual-dom string code already wrapped in a functions"},{"annotation":"return","type":"{String}","name":"Final","text":"virtual-dom string code already wrapped in a functions","theRestString":""}],"commentRange":[63114,63444],"fileName":"./index.js"},"addCustomHandler":{"annotation":"method","name":"addCustomHandler","text":"Method used to define a new custom Handlebars Helper","children":[{"annotation":"param","type":"{ExtenderCodeGeneratorObject}","name":"handlebars_custom_handlers","text":"","theRestString":"@return {Void}"},{"annotation":"return","type":"{Void}","text":"","theRestString":""}],"commentRange":[64061,64225],"fileName":"./index.js"},"installPlugin":{"annotation":"method","name":"installPlugin","text":"Install a plugin inside the code generator","children":[{"annotation":"param","type":"{Plugin}","name":"plugin_container","text":"","theRestString":"@return {Void}"},{"annotation":"return","type":"{Void}","text":"","theRestString":""}],"commentRange":[64277,64397],"fileName":"./index.js"}}},"blueHTML.ExtenderCodeGeneratorObject":{"annotation":"class","name":"ExtenderCodeGeneratorObject","text":"Object used to extend any of the code generators. In this object each property must be a function. Two kind of functions are supported: * **Extension Functions**: These are functions that will take the parameters from the Code generator and output a string code. This can be seen as a point to extend the code generator it self. This functions are distinguish by the property name they are attached to. In this case the name MUST start with the word 'single' and MUST NOT be 'singleInstance' Sample: ```javascript var blueHTML = require('blueHTML'); blueHTML.addCustomHandler({ 'singleTranslate': function (parsing_context, is_inside_context) { return 'h(\"div\",[])'; } }); ``` In this sample, that function will be called each time that in the HTML code appears something like: ```html <span>{{Translate 'some options'}}</span> ``` Each function MUST fulfill the following signature: **Function<NodesParsingContext,Boolean,Boolean>** where the output is string and the rest are the input parameter types. For the previous codes, the output will be: ```javascript function render(ctx) { return h('span', {}, [h('div',[])]); } ``` * **Helper Functions:** The second options are functions defined in almost the same way you define custom helpers in Handlebars. These functions are distinguish by the property name they are atteched to. In this case the name MUST start with the word 'singleInstance' Sample: ```javascript var blueHTML = require('blueHTML'); blueHTML.addCustomHandler({ 'singleInstanceTranslate': function (string_key_to_translate) { return 'key not found :('; } }); ``` In this sample, that function will be called each time that in the HTML code appears something like: ```html <span>{{Translate 'some options'}}</span> ``` The big difference with previous functions is the signature. While extension function must have a rigid signature that will be called by the code generator, helper functions can have any signature. In the same way you did with Handlebars. **Important Note:** 1. As you can guess, this functions are prefixed with the word *single* as their aim is to handle single helpers. In order word, by the time being **generic block are not supported!!** 2. The examples here applies to both Attributes and Tags","commentRange":[64447,67092],"fileName":"./index.js","module":{"annotation":"module","name":"blueHTML","text":"","commentRange":[62213,62613],"fileName":"./index.js"},"absoluteName":"blueHTML.ExtenderCodeGeneratorObject"}},"modules":{"blueHTML.Adapters":{"annotation":"module","name":"blueHTML.Adapters","text":"","commentRange":[2,144],"fileName":"./lib/Adapters/incrementalDOMAdapter.js"},"blueHTML":{"annotation":"module","name":"blueHTML","text":"","commentRange":[11890,11970],"fileName":"./lib/codeGenerator.Attributes.js"}},"files":{"./lib/Adapters/incrementalDOMAdapter.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[2,144],"fileName":"./lib/Adapters/incrementalDOMAdapter.js"},"./lib/Adapters/reactAdapter.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[1854,1978],"fileName":"./lib/Adapters/reactAdapter.js"},"./lib/Adapters/virtualDOMAdapter.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[7393,7501],"fileName":"./lib/Adapters/virtualDOMAdapter.js"},"./lib/codeGenerator.Attributes.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[11890,11970],"fileName":"./lib/codeGenerator.Attributes.js"},"./lib/codeGenerator.Base.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[26858,26932],"fileName":"./lib/codeGenerator.Base.js"},"./lib/codeGenerator.CustomHelpers.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[37472,37555],"fileName":"./lib/codeGenerator.CustomHelpers.js"},"./lib/codeGenerator.Tags.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[40876,40950],"fileName":"./lib/codeGenerator.Tags.js"},"./lib/codeGenerator.Utils.js //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// UTILS // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[55877,56272],"fileName":"./lib/codeGenerator.Utils.js //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// UTILS // ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////"},"./lib/codeGenerator.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[60043,60112],"fileName":"./lib/codeGenerator.js"},"./lib/hookContainer.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[61110,61331],"fileName":"./lib/hookContainer.js"},"./index.js":{"annotation":"filename","type":"{Foo}","name":"fileName","commentRange":[62213,62613],"fileName":"./index.js"}},"alias":{},"projectMetadata":"./package.json"}