# blueHTML
Simple [handlebar] to [virtual-dom] converter
[handlebar]:http://handlebarsjs.com/
[virtual-dom]:https://github.com/Matt-Esch/virtual-dom

## Overview
IMPORTANT: This project is in alpha stage, lot of work need to be done until it is finish!
(Do not use it on production).

Simple converter from HTML/Handlebars templates into virtual-dom.

PR Accepted (Specally Unit Test :D )

## API & Samples

```javascript
var blueHTML = require('blueHTML');

var handlebars_template = '<div id="content"><h1>{{title}}</h1>{{mainContent}}</div>';
var context = {
    title: 'Test Title',
    mainContent: 'Hello word'
};

var virtual_dom_string_template = blueHTML.generateVirtualDOM(handlebars_template);

var virtual_dom_fn = eval(virtual_dom_string_template);

var dom_output = virtual_dom_fn(context);

```

## How blueHTML works
The general structure of blueHTML is very simple. It is divided in 2 main sections; parsing and code generation.
As these are very independant you can use the current grammar to recognize HTMLish handlebars template and genrate any other DOM abstraction like incremental-dom.
It is important to notice that, although it is not the aim of this project, blueHTML end it up being another implementation of Handlebars, as it is require to support the its API to correctly convert it to Virtual-DOM.

Also take read the Code Generation section below to understand some of the difference between Handlebars and blueHTML.


### Parse

The parsing is done with a parser generated by [PEG.js](http://pegjs.org/).

You will find that apart from parsing and code generation division, blueHTML is also divided into Nodes and Attributes.
It turns out that there are many particularities in both, the grammar and the code generation than justify this second division.

For instance, it is easier to remove all break line character when parsing attributes or handle the code that generates code for attributes in a different context as the resulting Virtual-DOM is based on an object that is augemented rather and an array being concatenated (in the case of nodes).

One of the important points to have it clear, is that grammar used is not the same used by Handlebars. With Handlebars you are able to generate ANY template; C#, JavaScript, HTML or simple Plain Text.
This is not the case of blueHTML. Here we only accept/recognize a subset of HTML-Handlebars templates.

This means based on the current grammar, there are templates that WONT be recognized.
Grammar limitations:

  - Variable tag name are not supported. Sample:

```HTML
<{{tagName}}> some content here </{{tagName}}>
```

  - Spaces in simple evaluations. Sample

```HTML
<div> {{valid_variable_name}} {{  invalid_variable_name  }}} {{#if valid}} ... {{/if}} {{  #if Invalid }} ... {{ /if}} </div>
```

  - XML Structure is mandatory for non void tags. This means that you CANNOT condionally close a tag. Besides as a consecuence all open tag must have a closing tag. None child tag is allowed to close or add context outside the closing parent tag. Samples:

```HTML
<!-- Invalid Tags structure -->
<div> {{#if condition}}   </div> {{else}} <p>...</p> </div> {{/if}}
<!-- Here the IF has a invalid child a closing div that does not open inside the IF body. The first div never close -->

<!-- Invalid Tags structure -->
<a href="{{#if condition}}" {{else}} extra-values" {{/if}} />

<!-- Valid Tags structure -->
<input type="text" />
<input type="..." ></input>
```


### Code generation
For the code generation, the process is very simple. Based on the AST, a JSON object, returned by the parsed, it is just a matter or trave it.
The big difference in the final code between Handlebars and blueHTML, is that Handlebars has RunTime code runner.
In other word, when you add extra helper in Handlebars you are adding them to the runner, so your helpers are evaludated in runtime.
In blueHTML the produced code is a simple String, which means that you are responsible for the context where your extensions run. You must think that blueHTML will generate a string code, that later on will be executed.

#### New context creation
One aspect that I think is really important to understand, is the concept of context.
blueHTML is really simple, this is the only point that require understanding.
The group of ALL valid variables to be accessed in any time are those declared in the current context.
By default (or at the being of your template) blueHTML pre-assume that a generic context (ctx) exists and you can use any variable name. After this, there are two Handlebars helpers that define new context, EACH and WITH, currently only EACH is supported (see the Wiki for a list of supported features and it's status).
When a new

## Extensions
As the state of the code, there is basic support for extensions/custom helpers, neither all ways of customization provided by Handlebars are supported.
The best way to explain this is through an example:

```javascript
var blueHTML = require('blueHTML');

var handlebars_template = '<div id="content"><h1>{{MyCustomExtension variable1 'someString'}}</h1></div>';

//As the code is divided by Nodes and Attributes do not forget to define your custom helpers on the attribute sections
//blueHTML.addAttributesHandlers({

blueHTML.addNodesHandlers({
    // As you can see the pattern is singleInstance + <Helper name>
	'singleInstanceMyCustomExtension': function (variable1, text)
	{
		return variable1 + text + '!';
	}
});

var context = {
    title: 'Test Title',
    mainContent: 'Hello word'
};

var virtual_dom_string_template = blueHTML.generateVirtualDOM(handlebars_template);

var virtual_dom_fn = eval(virtual_dom_string_template);

var dom_output = virtual_dom_fn(context);

```


# License
The MIT License (MIT)

Copyright (c) 2015 Mictian

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
